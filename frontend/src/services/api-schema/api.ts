/* tslint:disable */
/* eslint-disable */
/**
 * arcadia-backend API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import { default as globalAxios } from '../api/api';

// Standard imports
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AddTitleGroupToSeriesRequest {
    'series_id': number;
    'title_group_id': number;
}
export interface AffiliatedArtistHierarchy {
    'artist': Artist;
    'artist_id': number;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'nickname'?: string | null;
    'roles': Array<ArtistRole>;
    'title_group_id': number;
}
export interface AffiliatedArtistLite {
    'artist_id': number;
    'name': string;
}
export interface AffiliatedEntityHierarchy {
    'created_at': string;
    'created_by_id': number;
    'entity': Entity;
    'entity_id': number;
    'id': number;
    'roles': Array<EntityRole>;
    'title_group_id': number;
}
export interface AppliedTitleGroupTag {
    'tag_id': number;
    'title_group_id': number;
}
export interface ArcadiaSettings {
    'default_css_sheet_name': string;
    'global_download_factor': number;
    'global_upload_factor': number;
    'open_signups': boolean;
    'user_class_name_on_signup': string;
}
export interface Artist {
    'created_at': string;
    'created_by_id': number;
    'description': string;
    'edition_groups_amount': number;
    'id': number;
    'leechers_amount': number;
    'name': string;
    'pictures': Array<string>;
    'seeders_amount': number;
    'snatches_amount': number;
    'title_groups_amount': number;
    'torrents_amount': number;
}
export interface ArtistAndTitleGroupsLite {
    'artist': Artist;
    'title_groups': Array<TitleGroupHierarchyLite>;
}
export interface ArtistLite {
    'id': number;
    'name': string;
    'pictures': Array<string>;
}

export const ArtistRole = {
    Main: 'main',
    Guest: 'guest',
    Producer: 'producer',
    Director: 'director',
    Cinematographer: 'cinematographer',
    Actor: 'actor',
    Writer: 'writer',
    Composer: 'composer',
    Remixer: 'remixer',
    Conductor: 'conductor',
    DjCompiler: 'dj_compiler',
    Arranger: 'arranger',
    Host: 'host',
    Author: 'author',
    Illustrator: 'illustrator',
    Editor: 'editor',
    Developer: 'developer',
    Designer: 'designer'
} as const;

export type ArtistRole = typeof ArtistRole[keyof typeof ArtistRole];


export interface ArtistSearchResult {
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'name': string;
    'pictures': Array<string>;
    'title_groups_amount': number;
}

export const AudioBitrateSampling = {
    _64: '64',
    _128: '128',
    _192: '192',
    _256: '256',
    _320: '320',
    ApsVbr: 'APS (VBR)',
    V2Vbr: 'V2 (VBR)',
    V1Vbr: 'V1 (VBR)',
    ApxVbr: 'APX (VBR)',
    V0Vbr: 'V0 (VBR)',
    Lossless: 'Lossless',
    _24bitLossless: '24bit Lossless',
    Dsd64: 'DSD64',
    Dsd128: 'DSD128',
    Dsd256: 'DSD256',
    Dsd512: 'DSD512',
    Other: 'Other'
} as const;

export type AudioBitrateSampling = typeof AudioBitrateSampling[keyof typeof AudioBitrateSampling];



export const AudioChannels = {
    _10: '1.0',
    _20: '2.0',
    _21: '2.1',
    _50: '5.0',
    _51: '5.1',
    _71: '7.1'
} as const;

export type AudioChannels = typeof AudioChannels[keyof typeof AudioChannels];



export const AudioCodec = {
    Mp2: 'mp2',
    Mp3: 'mp3',
    Aac: 'aac',
    Ac3: 'ac3',
    Dts: 'dts',
    Flac: 'flac',
    Pcm: 'pcm',
    TrueHd: 'true-hd',
    Opus: 'opus',
    Dsd: 'dsd'
} as const;

export type AudioCodec = typeof AudioCodec[keyof typeof AudioCodec];


export interface Collage {
    'category': CollageCategory;
    'cover'?: string | null;
    'created_at': string;
    'created_by_id': number;
    'description': string;
    'id': number;
    'name': string;
    'tags': Array<string>;
}



export const CollageCategory = {
    Personal: 'Personal',
    StaffPicks: 'Staff Picks',
    External: 'External',
    Theme: 'Theme'
} as const;

export type CollageCategory = typeof CollageCategory[keyof typeof CollageCategory];


export interface CollageEntry {
    'collage_id': number;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'note'?: string | null;
    'title_group_id': number;
}
export interface CollageLite {
    'cover'?: string | null;
    'id': number;
    'name': string;
}
export interface CollageSearchResult {
    'category': CollageCategory;
    'cover'?: string | null;
    'created_at': string;
    'created_by': UserLite;
    'created_by_id': number;
    'description': string;
    'entries_amount': number;
    'id': number;
    'last_entry_at': string;
    'name': string;
    'tags': Array<string>;
}



export const ContentType = {
    Movie: 'movie',
    Video: 'video',
    TvShow: 'tv_show',
    Music: 'music',
    Podcast: 'podcast',
    Software: 'software',
    Book: 'book',
    Collection: 'collection'
} as const;

export type ContentType = typeof ContentType[keyof typeof ContentType];


export interface Conversation {
    'created_at': string;
    'id': number;
    'receiver_id': number;
    'receiver_last_seen_at': string;
    'sender_id': number;
    'sender_last_seen_at': string;
    'subject': string;
}
export interface ConversationHierarchy {
    'created_at': string;
    'id': number;
    'messages': Array<ConversationMessageHierarchy>;
    'receiver': UserLiteAvatar;
    'receiver_last_seen_at': string;
    'sender': UserLiteAvatar;
    'sender_last_seen_at': string;
    'subject': string;
}
export interface ConversationMessage {
    'content': string;
    'conversation_id': number;
    'created_at': string;
    'created_by_id': number;
    'id': number;
}
export interface ConversationMessageHierarchy {
    'content': string;
    'created_at': string;
    'created_by': UserLiteAvatar;
    'id': number;
}
export interface ConversationMessageHierarchyLite {
    'created_at': string;
    'created_by': UserLite;
}
export interface ConversationOverview {
    'correspondant': UserLite;
    'created_at': string;
    'id': number;
    'last_message': ConversationMessageHierarchyLite;
    'receiver_id': number;
    'receiver_last_seen_at': string;
    'sender_id': number;
    'sender_last_seen_at': string;
    'subject': string;
}
export interface ConversationsOverview {
    'conversations': Array<ConversationOverview>;
}
export interface CssSheet {
    'created_at': string;
    'created_by_id': number;
    'css': string;
    'name': string;
    'preview_image_url': string;
}
export interface CssSheetsEnriched {
    'css_sheets': Array<CssSheet>;
    'default_sheet_name': string;
}
export interface DeleteTagRequest {
    'id': number;
}
export interface DeleteUserClass {
    'target_class_name': string;
}
export interface DeletedDonation {
    'id': number;
}
export interface Donation {
    'amount': number;
    'created_at': string;
    'created_by_id': number;
    'donated_at': string;
    'donated_by_id': number;
    'id': number;
    'note'?: string | null;
}

export const DonationOrderBy = {
    DonatedAt: 'donated_at',
    CreatedAt: 'created_at',
    Amount: 'amount'
} as const;

export type DonationOrderBy = typeof DonationOrderBy[keyof typeof DonationOrderBy];


export interface DonationSearchResult {
    'amount': number;
    'created_at': string;
    'created_by': UserLiteAvatar;
    'created_by_id': number;
    'donated_at': string;
    'donated_by': UserLiteAvatar;
    'donated_by_id': number;
    'id': number;
    'note'?: string | null;
}
export interface EditedArtist {
    'description': string;
    'id': number;
    'name': string;
    'pictures': Array<string>;
}
export interface EditedCssSheet {
    'css': string;
    'name': string;
    'old_name': string;
    'preview_image_url': string;
}
export interface EditedDonation {
    'amount': number;
    'donated_at': string;
    'donated_by_id': number;
    'id': number;
    'note'?: string | null;
}
export interface EditedForumCategory {
    'id': number;
    'name': string;
}
export interface EditedForumPost {
    'content': string;
    'id': number;
    'locked': boolean;
    'sticky': boolean;
}
export interface EditedForumSubCategory {
    'id': number;
    'name': string;
}
export interface EditedForumThread {
    'forum_sub_category_id': number;
    'id': number;
    'locked': boolean;
    'name': string;
    'sticky': boolean;
}
export interface EditedSeries {
    'banners': Array<string>;
    'covers': Array<string>;
    'description': string;
    'id': number;
    'name': string;
    'tags': Array<string>;
}
export interface EditedTitleGroup {
    'category'?: TitleGroupCategory | null;
    'content_type': ContentType;
    'country_from'?: string | null;
    'covers': Array<string>;
    'description': string;
    'embedded_links': { [key: string]: { [key: string]: string; }; };
    'external_links': Array<string>;
    'id': number;
    'master_group_id'?: number | null;
    'name': string;
    'name_aliases': Array<string>;
    'original_language'?: Language | null;
    'original_release_date': string;
    'platform'?: Platform | null;
    'screenshots': Array<string>;
    'tagline'?: string | null;
}


export interface EditedTitleGroupBookmark {
    'description'?: string | null;
    'id': number;
}
export interface EditedTitleGroupComment {
    'content': string;
    'locked': boolean;
}
export interface EditedTitleGroupTag {
    'id': number;
    'name': string;
    'synonyms': Array<string>;
}
export interface EditedTorrent {
    'audio_bitrate'?: number | null;
    'audio_bitrate_sampling'?: AudioBitrateSampling | null;
    'audio_channels'?: AudioChannels | null;
    'audio_codec'?: AudioCodec | null;
    'container': string;
    'description'?: string | null;
    'duration'?: number | null;
    'edition_group_id': number;
    'extras': Array<Extras>;
    'features': Array<Features>;
    'id': number;
    'languages': Array<Language>;
    'mediainfo'?: string | null;
    'release_group'?: string | null;
    'release_name'?: string | null;
    'subtitle_languages': Array<Language>;
    'uploaded_as_anonymous': boolean;
    'video_codec'?: VideoCodec | null;
    'video_resolution'?: VideoResolution | null;
    'video_resolution_other_x'?: number | null;
    'video_resolution_other_y'?: number | null;
}


export interface EditedUser {
    'avatar'?: string | null;
    'description': string;
    'email': string;
}
export interface EditedUserClass {
    'automatic_demotion': boolean;
    'automatic_promotion': boolean;
    'name': string;
    'new_permissions': Array<UserPermission>;
    'promotion_allowed_while_warned': boolean;
    'required_account_age_in_days': number;
    'required_downloaded': number;
    'required_forum_posts': number;
    'required_forum_posts_in_unique_threads': number;
    'required_ratio': number;
    'required_seeding_size': number;
    'required_title_group_comments': number;
    'required_torrent_snatched': number;
    'required_torrent_uploads': number;
    'required_torrent_uploads_in_unique_title_groups': number;
    'required_uploaded': number;
}
export interface EditedWikiArticle {
    'body': string;
    'id': number;
    'title': string;
}
export interface EditionGroup {
    'additional_information': { [key: string]: string; };
    'covers': Array<string>;
    'created_at': string;
    'created_by_id': number;
    'description'?: string | null;
    'distributor'?: string | null;
    'external_links': Array<string>;
    'id': number;
    'name'?: string | null;
    'release_date': string;
    'source'?: Source | null;
    'title_group_id': number;
    'updated_at': string;
}


export interface EditionGroupHierarchy {
    'additional_information': { [key: string]: string; };
    'covers': Array<string>;
    'created_at': string;
    'created_by_id': number;
    'description'?: string | null;
    'distributor'?: string | null;
    'external_links': Array<string>;
    'id': number;
    'name'?: string | null;
    'release_date': string;
    'source'?: Source | null;
    'title_group_id': number;
    'torrents': Array<TorrentHierarchy>;
    'updated_at': string;
}


export interface EditionGroupHierarchyLite {
    'additional_information': { [key: string]: string; };
    'covers': Array<string>;
    'distributor'?: string | null;
    'id': number;
    'name'?: string | null;
    'release_date': string;
    'source'?: Source | null;
    'title_group_id': number;
    'torrents': Array<TorrentHierarchyLite>;
}


export interface EditionGroupInfoLite {
    'additional_information': { [key: string]: string; };
    'distributor'?: string | null;
    'id': number;
    'name'?: string | null;
    'release_date': string;
    'source'?: Source | null;
}


export interface Entity {
    'created_at': string;
    'created_by_id': number;
    'description': string;
    'id': number;
    'name': string;
    'pictures': Array<string>;
}

export const EntityRole = {
    Producer: 'producer',
    Developer: 'developer',
    Designer: 'designer',
    Label: 'label',
    Network: 'network'
} as const;

export type EntityRole = typeof EntityRole[keyof typeof EntityRole];



export const ExternalDB = {
    Tmdb: 'tmdb'
} as const;

export type ExternalDB = typeof ExternalDB[keyof typeof ExternalDB];


export interface ExternalDBData {
    'affiliated_artists': Array<AffiliatedArtistHierarchy>;
    'edition_group'?: UserCreatedEditionGroup | null;
    'existing_title_group_id'?: number | null;
    'title_group'?: UserCreatedTitleGroup | null;
}

export const Extras = {
    Booklet: 'booklet',
    Manual: 'manual',
    BehindTheScenes: 'behind_the_scenes',
    DeletedScenes: 'deleted_scenes',
    Featurette: 'featurette',
    Trailer: 'trailer',
    Other: 'other'
} as const;

export type Extras = typeof Extras[keyof typeof Extras];



export const Features = {
    Hdr: 'HDR',
    Hdr10: 'HDR 10',
    Hdr102: 'HDR 10+',
    Dv: 'DV',
    Commentary: 'Commentary',
    Remux: 'Remux',
    _3D: '3D',
    Ocr: 'OCR',
    Cue: 'Cue'
} as const;

export type Features = typeof Features[keyof typeof Features];


export interface ForumCategory {
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'name': string;
}
export interface ForumCategoryHierarchy {
    'id': number;
    'name': string;
    'sub_categories': Array<ForumSubCategoryHierarchy>;
}
export interface ForumCategoryLite {
    'id': number;
    'name': string;
}
export interface ForumOverview {
    'forum_categories': Array<ForumCategoryHierarchy>;
    'latest_posts_in_threads': Array<ForumSearchResult>;
}
export interface ForumPost {
    'content': string;
    'created_at': string;
    'created_by_id': number;
    'forum_thread_id': number;
    'id': number;
    'locked': boolean;
    'sticky': boolean;
    'updated_at': string;
}
export interface ForumPostAndThreadName {
    'content': string;
    'created_at': string;
    'created_by_id': number;
    'forum_thread_id': number;
    'forum_thread_name': string;
    'id': number;
    'sticky': boolean;
    'updated_at': string;
}
export interface ForumPostHierarchy {
    'content': string;
    'created_at': string;
    'created_by': UserLiteAvatar;
    'forum_thread_id': number;
    'id': number;
    'locked': boolean;
    'sticky': boolean;
    'updated_at': string;
}
export interface ForumSearchQuery {
    'page': number;
    'page_size': number;
    'thread_name'?: string | null;
}
export interface ForumSearchResult {
    'category_id': number;
    'category_name': string;
    'post': string;
    'post_created_at': string;
    'post_created_by_id': number;
    'post_created_by_username': string;
    'post_id': number;
    'sub_category_id': number;
    'sub_category_name': string;
    'thread_id': number;
    'thread_name': string;
}
export interface ForumSubCategory {
    'created_at': string;
    'created_by_id': number;
    'forbidden_classes': Array<string>;
    'forum_category_id': number;
    'id': number;
    'name': string;
    'posts_amount': number;
    'threads_amount': number;
}
export interface ForumSubCategoryHierarchy {
    'category': ForumCategoryLite;
    'forbidden_classes': Array<string>;
    'id': number;
    'latest_post_in_thread'?: ForumThreadPostLite | null;
    'name': string;
    'posts_amount': number;
    'threads'?: Array<ForumThreadHierarchy> | null;
    'threads_amount': number;
}
export interface ForumThread {
    'created_at': string;
    'created_by_id': number;
    'forum_sub_category_id': number;
    'id': number;
    'locked': boolean;
    'name': string;
    'posts_amount': number;
    'sticky': boolean;
}
export interface ForumThreadEnriched {
    'created_at': string;
    'created_by_id': number;
    'forum_category_id': number;
    'forum_category_name': string;
    'forum_sub_category_id': number;
    'forum_sub_category_name': string;
    'id': number;
    'is_subscribed': boolean;
    'locked': boolean;
    'name': string;
    'posts_amount': number;
    'sticky': boolean;
}
export interface ForumThreadHierarchy {
    'created_at': string;
    'created_by': UserLite;
    'id': number;
    'latest_post': ForumThreadPostLite;
    'locked': boolean;
    'name': string;
    'posts_amount': number;
    'sticky': boolean;
}
export interface ForumThreadPostLite {
    'created_at': string;
    'created_by': UserLite;
    'id': number;
    'name': string;
    'thread_id': number;
}
export interface GetForumThreadPostsQuery {
    'page'?: number | null;
    'page_size': number;
    'post_id'?: number | null;
    'thread_id': number;
}
export interface GetUserApplicationsQuery {
    'page'?: number | null;
    'page_size'?: number | null;
    'status'?: UserApplicationStatus | null;
}


export interface Gift {
    'bonus_points': number;
    'freeleech_tokens': number;
    'id': number;
    'message': string;
    'receiver_id': number;
    'sender_id': number;
    'sent_at': string;
}
export interface HomePage {
    'latest_posts_in_threads': Array<ForumSearchResult>;
    'latest_uploads': Array<TitleGroupLite>;
    'recent_announcements': Array<ForumPostAndThreadName>;
    'stats': HomeStats;
}
export interface HomeStats {
    'artists': number;
    'enabled_users': number;
    'entities': number;
    'titles': number;
    'torrents': number;
    'torrents_uploaded_today': number;
    'users_active_this_month': number;
    'users_active_this_week': number;
    'users_active_today': number;
}
export interface Invitation {
    'created_at': string;
    'expires_at': string;
    'id': number;
    'invitation_key': string;
    'message': string;
    'receiver_email': string;
    'receiver_id'?: number | null;
    'sender_id': number;
    'user_application_id'?: number | null;
}

export const Language = {
    Albanian: 'Albanian',
    Arabic: 'Arabic',
    Belarusian: 'Belarusian',
    Bengali: 'Bengali',
    Bosnian: 'Bosnian',
    Bulgarian: 'Bulgarian',
    Cantonese: 'Cantonese',
    Catalan: 'Catalan',
    Chinese: 'Chinese',
    Croatian: 'Croatian',
    Czech: 'Czech',
    Danish: 'Danish',
    Dutch: 'Dutch',
    English: 'English',
    Estonian: 'Estonian',
    Finnish: 'Finnish',
    French: 'French',
    German: 'German',
    Greek: 'Greek',
    Hebrew: 'Hebrew',
    Hindi: 'Hindi',
    Hungarian: 'Hungarian',
    Icelandic: 'Icelandic',
    Indonesian: 'Indonesian',
    Italian: 'Italian',
    Japanese: 'Japanese',
    Kannada: 'Kannada',
    Korean: 'Korean',
    Macedonian: 'Macedonian',
    Malayalam: 'Malayalam',
    Mandarin: 'Mandarin',
    Nepali: 'Nepali',
    Norwegian: 'Norwegian',
    Persian: 'Persian',
    Polish: 'Polish',
    Portuguese: 'Portuguese',
    Romanian: 'Romanian',
    Russian: 'Russian',
    Serbian: 'Serbian',
    Spanish: 'Spanish',
    Swedish: 'Swedish',
    Tamil: 'Tamil',
    Tagalog: 'Tagalog',
    Telugu: 'Telugu',
    Thai: 'Thai',
    Turkish: 'Turkish',
    Ukrainian: 'Ukrainian',
    Vietnamese: 'Vietnamese',
    Wolof: 'Wolof',
    Other: 'Other'
} as const;

export type Language = typeof Language[keyof typeof Language];


export interface Login {
    'password': string;
    'remember_me': boolean;
    'username': string;
}
export interface LoginResponse {
    'refresh_token': string;
    'token': string;
}
export interface MasterGroup {
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'name'?: string | null;
    'updated_at': string;
}
export interface NotificationForumThreadPost {
    'created_at': string;
    'forum_post_id': number;
    'forum_thread_id': number;
    'forum_thread_name': string;
    'id': number;
    'read_status': boolean;
}

export const OrderByDirection = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type OrderByDirection = typeof OrderByDirection[keyof typeof OrderByDirection];


export interface PaginatedResultsArtistSearchResult {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsArtistSearchResultResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsArtistSearchResultResultsInner {
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'name': string;
    'pictures': Array<string>;
    'title_groups_amount': number;
}
export interface PaginatedResultsCollageSearchResult {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsCollageSearchResultResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsCollageSearchResultResultsInner {
    'category': CollageCategory;
    'cover'?: string | null;
    'created_at': string;
    'created_by': UserLite;
    'created_by_id': number;
    'description': string;
    'entries_amount': number;
    'id': number;
    'last_entry_at': string;
    'name': string;
    'tags': Array<string>;
}


export interface PaginatedResultsForumPostHierarchy {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsForumPostHierarchyResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsForumPostHierarchyResultsInner {
    'content': string;
    'created_at': string;
    'created_by': UserLiteAvatar;
    'forum_thread_id': number;
    'id': number;
    'locked': boolean;
    'sticky': boolean;
    'updated_at': string;
}
export interface PaginatedResultsForumSearchResult {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsForumSearchResultResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsForumSearchResultResultsInner {
    'category_id': number;
    'category_name': string;
    'post': string;
    'post_created_at': string;
    'post_created_by_id': number;
    'post_created_by_username': string;
    'post_id': number;
    'sub_category_id': number;
    'sub_category_name': string;
    'thread_id': number;
    'thread_name': string;
}
export interface PaginatedResultsTitleGroupHierarchyLite {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsTitleGroupHierarchyLiteResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsTitleGroupHierarchyLiteResultsInner {
    'affiliated_artists': Array<AffiliatedArtistLite>;
    'category'?: TitleGroupCategory | null;
    'content_type': ContentType;
    'covers': Array<string>;
    'edition_groups': Array<EditionGroupHierarchyLite>;
    'id': number;
    'name': string;
    'original_release_date': string;
    'platform'?: Platform | null;
    'tags': Array<string>;
}


export interface PaginatedResultsTitleGroupTagEnriched {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsTitleGroupTagEnrichedResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsTitleGroupTagEnrichedResultsInner {
    'created_at': string;
    'created_by': UserLite;
    'id': number;
    'name': string;
    'synonyms': Array<string>;
    'uses': number;
}
export interface PaginatedResultsTitleGroupTagLite {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsTitleGroupTagLiteResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsTitleGroupTagLiteResultsInner {
    'id': number;
    'name': string;
    'synonyms': Array<string>;
}
export interface PaginatedResultsTorrentHierarchyLite {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsTorrentHierarchyLiteResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsTorrentHierarchyLiteResultsInner {
    'audio_bitrate'?: number | null;
    'audio_bitrate_sampling'?: AudioBitrateSampling | null;
    'audio_channels'?: AudioChannels | null;
    'audio_codec'?: AudioCodec | null;
    'container': string;
    'created_at': string;
    'download_factor': number;
    'duration'?: number | null;
    'edition_group_id': number;
    'extras': Array<Extras>;
    'features': Array<Features>;
    'id': number;
    'languages': Array<Language>;
    'leechers': number;
    'peer_status'?: PeerStatus | null;
    'release_group'?: string | null;
    'release_name'?: string | null;
    'reports': Array<TorrentReport>;
    'seeders': number;
    'size': number;
    'snatched': number;
    'staff_checked': boolean;
    'subtitle_languages': Array<Language>;
    'times_completed': number;
    'trumpable'?: string | null;
    'upload_factor': number;
    'video_codec'?: VideoCodec | null;
    'video_resolution'?: VideoResolution | null;
    'video_resolution_other_x'?: number | null;
    'video_resolution_other_y'?: number | null;
}


export interface PaginatedResultsUnauthorizedAccess {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsUnauthorizedAccessResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsUnauthorizedAccessResultsInner {
    'created_at': string;
    'id': number;
    'missing_permission': UserPermission;
    'path': string;
    'user': UserLiteAvatar;
}


export interface PaginatedResultsUserApplication {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsUserApplicationResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsUserApplicationResultsInner {
    'applied_from_ip': string;
    'body': string;
    'created_at': string;
    'email': string;
    'id': number;
    'referral': string;
    'staff_note': string;
    'status': UserApplicationStatus;
}


export interface Peer {
    'agent'?: string | null;
    'first_seen_at': string;
    'ip': string;
    'last_seen_at': string;
    'port': number;
    'real_downloaded': number;
    'real_uploaded': number;
    'status': PeerStatus;
}



export const PeerStatus = {
    Seeding: 'seeding',
    Leeching: 'leeching',
    Snatched: 'snatched',
    Grabbed: 'grabbed'
} as const;

export type PeerStatus = typeof PeerStatus[keyof typeof PeerStatus];



export const Platform = {
    Windows: 'Windows',
    Linux: 'Linux',
    MacOs: 'MacOS',
    Xbox: 'Xbox'
} as const;

export type Platform = typeof Platform[keyof typeof Platform];


export interface Profile {
    'last_five_snatched_torrents': Array<TitleGroupHierarchyLite>;
    'last_five_uploaded_torrents': Array<TitleGroupHierarchyLite>;
    'peers': Array<Peer>;
    'unread_conversations_amount': number;
    'unread_notifications_amount_forum_thread_posts': number;
    'user': User;
    'user_warnings': Array<UserWarning>;
}
export interface PublicProfile {
    'last_five_snatched_torrents': Array<TitleGroupHierarchyLite>;
    'last_five_uploaded_torrents': Array<TitleGroupHierarchyLite>;
    'user': PublicUser;
}
export interface PublicRating {
    'rating': number;
    'service': ExternalDB;
    'votes': number;
}


export interface PublicUser {
    'artist_comments': number;
    'avatar'?: string | null;
    'average_seeding_time': number;
    'banned': boolean;
    'bonus_points': number;
    'class_locked': boolean;
    'class_name': string;
    'collages_started': number;
    'created_at': string;
    'description': string;
    'downloaded': number;
    'forum_posts': number;
    'forum_threads': number;
    'id': number;
    'invitations': number;
    'invited': number;
    'last_seen': string;
    'leeching': number;
    'ratio': number;
    'real_downloaded': number;
    'real_uploaded': number;
    'request_comments': number;
    'requests_filled': number;
    'requests_voted': number;
    'required_ratio': number;
    'seeding': number;
    'seeding_size': number;
    'snatched': number;
    'torrent_comments': number;
    'uploaded': number;
    'username': string;
    'warned': boolean;
}
export interface RefreshToken {
    'refresh_token': string;
}
export interface Register {
    'email': string;
    'password': string;
    'password_verify': string;
    'username': string;
}
export interface RemovedTitleGroupTag {
    'tag_name': string;
    'title_group_id': number;
}
export interface SearchArtistsQuery {
    'name'?: string | null;
    'page': number;
    'page_size': number;
}
export interface SearchCollagesLiteQuery {
    'name': string;
    'results_amount': number;
}
export interface SearchCollagesQuery {
    'name'?: string | null;
    'page': number;
    'page_size': number;
    'tags'?: Array<string> | null;
}
export interface SearchDonationsQuery {
    'created_by_id'?: number | null;
    'donated_at_end'?: string | null;
    'donated_at_start'?: string | null;
    'donated_by_id'?: number | null;
    'max_amount'?: number | null;
    'min_amount'?: number | null;
    'order_by_column'?: DonationOrderBy;
    'order_by_direction'?: OrderByDirection;
    'page': number;
    'page_size': number;
}


export interface SearchDonationsResponse {
    'page': number;
    'page_size': number;
    'results': Array<DonationSearchResult>;
    'total_amount': number;
    'total_items': number;
    'unique_donors_count': number;
}
export interface SearchSeriesQuery {
    'name'?: string | null;
    'page': number;
    'page_size': number;
    'tags'?: Array<string> | null;
}
export interface SearchTitleGroupTagsLiteQuery {
    'name': string;
    'page': number;
    'page_size': number;
}
export interface SearchTitleGroupTagsQuery {
    'name': string;
    'order_by_column': TitleGroupTagSearchOrderByColumn;
    'order_by_direction': OrderByDirection;
    'page': number;
    'page_size': number;
}


export interface SearchTorrentRequestsQuery {
    'page'?: number | null;
    'page_size'?: number | null;
    'tags'?: Array<string> | null;
    'title_group_name'?: string | null;
}
export interface SearchUnauthorizedAccessQuery {
    'from_date': string;
    'page': number;
    'page_size': number;
    'permission'?: UserPermission | null;
    'sort_by_column': UnauthorizedAccessSortByColumn;
    'sort_by_direction': SortByDirection;
    'to_date': string;
    'user_id'?: number | null;
}


export interface SentInvitation {
    'message': string;
    'receiver_email': string;
    'user_application_id'?: number | null;
}
export interface Series {
    'banners'?: Array<string> | null;
    'covers': Array<string>;
    'created_at': string;
    'created_by_id': number;
    'description': string;
    'id': number;
    'name': string;
    'tags': Array<string>;
    'updated_at': string;
}
export interface SeriesAndTitleGroupHierarchyLite {
    'series': Series;
    'title_groups': Array<TitleGroupHierarchyLite>;
}
export interface SeriesLite {
    'id': number;
    'name': string;
}
export interface SeriesSearchResponse {
    'results': Array<SeriesSearchResult>;
    'total_items': number;
}
export interface SeriesSearchResult {
    'banners'?: Array<string> | null;
    'covers': Array<string>;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'name': string;
    'tags': Array<string>;
    'title_groups_amount': number;
}

export const SortByDirection = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortByDirection = typeof SortByDirection[keyof typeof SortByDirection];



export const Source = {
    Cd: 'CD',
    Vinyl: 'Vinyl',
    Web: 'Web',
    Soundboard: 'Soundboard',
    Sacd: 'SACD',
    Dat: 'DAT',
    Cassette: 'Cassette',
    BluRay: 'Blu-Ray',
    LaserDisc: 'LaserDisc',
    HdDvd: 'HD-DVD',
    Hdtv: 'HDTV',
    Pdtv: 'PDTV',
    Tv: 'TV',
    Vhs: 'VHS',
    Mixed: 'Mixed',
    PhysicalBook: 'Physical Book',
    Dvd: 'DVD'
} as const;

export type Source = typeof Source[keyof typeof Source];


export interface StaffPm {
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'resolved': boolean;
    'subject': string;
}
export interface StaffPmHierarchy {
    'created_at': string;
    'created_by': UserLiteAvatar;
    'id': number;
    'messages': Array<StaffPmMessageHierarchy>;
    'resolved': boolean;
    'subject': string;
}
export interface StaffPmMessage {
    'content': string;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'staff_pm_id': number;
}
export interface StaffPmMessageHierarchy {
    'content': string;
    'created_at': string;
    'created_by': UserLiteAvatar;
    'id': number;
}
export interface StaffPmMessageHierarchyLite {
    'created_at': string;
    'created_by': UserLite;
}
export interface StaffPmOverview {
    'created_at': string;
    'created_by': UserLite;
    'id': number;
    'last_message': StaffPmMessageHierarchyLite;
    'resolved': boolean;
    'subject': string;
}
export interface TitleGroup {
    'category'?: TitleGroupCategory | null;
    'content_type': ContentType;
    'country_from'?: string | null;
    'covers': Array<string>;
    'created_at': string;
    'created_by_id': number;
    'description': string;
    'embedded_links': { [key: string]: { [key: string]: string; }; };
    'external_links': Array<string>;
    'id': number;
    'master_group_id'?: number | null;
    'name': string;
    'name_aliases': Array<string>;
    'original_language'?: Language | null;
    'original_release_date': string;
    'platform'?: Platform | null;
    'public_ratings': Array<PublicRating>;
    'screenshots': Array<string>;
    'series_id'?: number | null;
    'tagline'?: string | null;
    'tags': Array<string>;
    'updated_at': string;
}


export interface TitleGroupAndAssociatedData {
    'affiliated_artists': Array<AffiliatedArtistHierarchy>;
    'affiliated_entities': Array<AffiliatedEntityHierarchy>;
    'collages': Array<CollageSearchResult>;
    'edition_groups': Array<EditionGroupHierarchy>;
    'in_same_master_group': Array<TitleGroupLite>;
    'is_subscribed': boolean;
    'series': SeriesLite;
    'title_group': TitleGroup;
    'title_group_comments': Array<TitleGroupCommentHierarchy>;
    'torrent_requests': Array<TorrentRequestHierarchyLite>;
}
export interface TitleGroupBookmark {
    'created_at': string;
    'description'?: string | null;
    'id': number;
    'title_group_id': number;
    'user_id': number;
}

export const TitleGroupCategory = {
    Ep: 'Ep',
    Album: 'Album',
    Single: 'Single',
    Soundtrack: 'Soundtrack',
    Anthology: 'Anthology',
    Compilation: 'Compilation',
    Remix: 'Remix',
    Bootleg: 'Bootleg',
    Mixtape: 'Mixtape',
    ConcertRecording: 'ConcertRecording',
    DjMix: 'DjMix',
    FeatureFilm: 'FeatureFilm',
    ShortFilm: 'ShortFilm',
    Game: 'Game',
    Program: 'Program',
    Illustrated: 'Illustrated',
    Periodical: 'Periodical',
    Book: 'Book',
    Article: 'Article',
    Manual: 'Manual',
    Other: 'Other'
} as const;

export type TitleGroupCategory = typeof TitleGroupCategory[keyof typeof TitleGroupCategory];


export interface TitleGroupComment {
    'answers_to_comment_id'?: number | null;
    'content': string;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'locked': boolean;
    'refers_to_torrent_id'?: number | null;
    'title_group_id': number;
    'updated_at': string;
}
export interface TitleGroupCommentHierarchy {
    'answers_to_comment_id'?: number | null;
    'content': string;
    'created_at': string;
    'created_by': UserLiteAvatar;
    'created_by_id': number;
    'id': number;
    'locked': boolean;
    'refers_to_torrent_id'?: number | null;
    'title_group_id': number;
    'updated_at': string;
}
export interface TitleGroupHierarchyLite {
    'affiliated_artists': Array<AffiliatedArtistLite>;
    'category'?: TitleGroupCategory | null;
    'content_type': ContentType;
    'covers': Array<string>;
    'edition_groups': Array<EditionGroupHierarchyLite>;
    'id': number;
    'name': string;
    'original_release_date': string;
    'platform'?: Platform | null;
    'tags': Array<string>;
}


export interface TitleGroupLite {
    'content_type': ContentType;
    'covers': Array<string>;
    'edition_groups': Array<EditionGroupInfoLite>;
    'id': number;
    'name': string;
    'original_release_date': string;
    'platform'?: Platform | null;
}


export interface TitleGroupTag {
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'name': string;
    'synonyms': Array<string>;
}
export interface TitleGroupTagEnriched {
    'created_at': string;
    'created_by': UserLite;
    'id': number;
    'name': string;
    'synonyms': Array<string>;
    'uses': number;
}
export interface TitleGroupTagLite {
    'id': number;
    'name': string;
    'synonyms': Array<string>;
}

export const TitleGroupTagSearchOrderByColumn = {
    CreatedAt: 'created_at',
    Uses: 'uses',
    Name: 'name'
} as const;

export type TitleGroupTagSearchOrderByColumn = typeof TitleGroupTagSearchOrderByColumn[keyof typeof TitleGroupTagSearchOrderByColumn];


export interface Torrent {
    'audio_bitrate'?: number | null;
    'audio_bitrate_sampling'?: AudioBitrateSampling | null;
    'audio_channels'?: AudioChannels | null;
    'audio_codec'?: AudioCodec | null;
    'container': string;
    'created_at': string;
    'created_by_id': number;
    'deleted_at': string;
    'deleted_by_id'?: number | null;
    'description'?: string | null;
    'download_factor': number;
    'duration'?: number | null;
    'edition_group_id': number;
    'extras': Array<Extras>;
    'features': Array<Features>;
    'file_amount_per_type': { [key: string]: string; };
    'file_list': { [key: string]: string; };
    'id': number;
    'info_hash': Array<number>;
    'languages': Array<Language>;
    'leechers': number;
    'mediainfo'?: string | null;
    'release_group'?: string | null;
    'release_name'?: string | null;
    'seeders': number;
    'size': number;
    'snatched': number;
    'staff_checked': boolean;
    'subtitle_languages': Array<Language>;
    'times_completed': number;
    'trumpable'?: string | null;
    'updated_at': string;
    'upload_factor': number;
    'upload_method': string;
    'uploaded_as_anonymous': boolean;
    'video_codec'?: VideoCodec | null;
    'video_resolution'?: VideoResolution | null;
    'video_resolution_other_x'?: number | null;
    'video_resolution_other_y'?: number | null;
}


export interface TorrentHierarchy {
    'audio_bitrate'?: number | null;
    'audio_bitrate_sampling'?: AudioBitrateSampling | null;
    'audio_channels'?: AudioChannels | null;
    'audio_codec'?: AudioCodec | null;
    'container': string;
    'created_at': string;
    'created_by'?: UserLite | null;
    'created_by_id'?: number | null;
    'description'?: string | null;
    'download_factor': number;
    'duration'?: number | null;
    'edition_group_id': number;
    'extras': Array<Extras>;
    'features': Array<Features>;
    'file_amount_per_type': { [key: string]: string; };
    'file_list': { [key: string]: string; };
    'id': number;
    'languages': Array<Language>;
    'leechers': number;
    'mediainfo'?: string | null;
    'peer_status'?: PeerStatus | null;
    'release_group'?: string | null;
    'release_name'?: string | null;
    'reports': Array<TorrentReport>;
    'seeders': number;
    'size': number;
    'snatched': number;
    'staff_checked': boolean;
    'subtitle_languages': Array<Language>;
    'times_completed': number;
    'trumpable'?: string | null;
    'updated_at': string;
    'upload_factor': number;
    'uploaded_as_anonymous': boolean;
    'video_codec'?: VideoCodec | null;
    'video_resolution'?: VideoResolution | null;
    'video_resolution_other_x'?: number | null;
    'video_resolution_other_y'?: number | null;
}


export interface TorrentHierarchyLite {
    'audio_bitrate'?: number | null;
    'audio_bitrate_sampling'?: AudioBitrateSampling | null;
    'audio_channels'?: AudioChannels | null;
    'audio_codec'?: AudioCodec | null;
    'container': string;
    'created_at': string;
    'download_factor': number;
    'duration'?: number | null;
    'edition_group_id': number;
    'extras': Array<Extras>;
    'features': Array<Features>;
    'id': number;
    'languages': Array<Language>;
    'leechers': number;
    'peer_status'?: PeerStatus | null;
    'release_group'?: string | null;
    'release_name'?: string | null;
    'reports': Array<TorrentReport>;
    'seeders': number;
    'size': number;
    'snatched': number;
    'staff_checked': boolean;
    'subtitle_languages': Array<Language>;
    'times_completed': number;
    'trumpable'?: string | null;
    'upload_factor': number;
    'video_codec'?: VideoCodec | null;
    'video_resolution'?: VideoResolution | null;
    'video_resolution_other_x'?: number | null;
    'video_resolution_other_y'?: number | null;
}


export interface TorrentReport {
    'description': string;
    'id': number;
    'reported_at': string;
    'reported_by_id': number;
    'reported_torrent_id': number;
}
export interface TorrentRequest {
    'audio_bitrate_sampling': Array<AudioBitrateSampling>;
    'audio_channels': Array<AudioChannels>;
    'audio_codec': Array<AudioCodec>;
    'container': Array<string>;
    'created_at': string;
    'created_by_id': number;
    'description'?: string | null;
    'edition_name'?: string | null;
    'features': Array<Features>;
    'filled_at': string;
    'filled_by_torrent_id'?: number | null;
    'filled_by_user_id'?: number | null;
    'id': number;
    'languages': Array<Language>;
    'release_group'?: string | null;
    'source': Array<Source>;
    'subtitle_languages': Array<Language>;
    'title_group_id': number;
    'updated_at': string;
    'video_codec': Array<VideoCodec>;
    'video_resolution': Array<VideoResolution>;
    'video_resolution_other_x'?: number | null;
    'video_resolution_other_y'?: number | null;
}
export interface TorrentRequestAndAssociatedData {
    'affiliated_artists': Array<AffiliatedArtistHierarchy>;
    'comments': Array<TorrentRequestCommentHierarchy>;
    'series': SeriesLite;
    'title_group': TitleGroup;
    'torrent_request': TorrentRequest;
    'votes': Array<TorrentRequestVoteHierarchy>;
}
export interface TorrentRequestBounty {
    'bonus_points': number;
    'upload': number;
}
export interface TorrentRequestComment {
    'content': string;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'torrent_request_id': number;
    'updated_at': string;
}
export interface TorrentRequestCommentHierarchy {
    'content': string;
    'created_at': string;
    'created_by': UserLiteAvatar;
    'created_by_id': number;
    'id': number;
    'torrent_request_id': number;
    'updated_at': string;
}
export interface TorrentRequestFill {
    'torrent_id': number;
    'torrent_request_id': number;
}
export interface TorrentRequestHierarchyLite {
    'bounty': TorrentRequestBounty;
    'created_by': UserLite;
    'torrent_request': TorrentRequest;
    'user_votes_amount': number;
}
export interface TorrentRequestVote {
    'bounty_bonus_points': number;
    'bounty_upload': number;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'torrent_request_id': number;
}
export interface TorrentRequestVoteHierarchy {
    'bounty_bonus_points': number;
    'bounty_upload': number;
    'created_at': string;
    'created_by': UserLite;
    'created_by_id': number;
    'id': number;
    'torrent_request_id': number;
}
export interface TorrentRequestWithTitleGroupLite {
    'affiliated_artists': Array<AffiliatedArtistHierarchy>;
    'bounty': TorrentRequestBounty;
    'series': SeriesLite;
    'title_group': TitleGroupLite;
    'torrent_request': TorrentRequest;
    'user_votes_amount': number;
}
export interface TorrentSearch {
    'artist_id'?: number | null;
    'collage_id'?: number | null;
    'order_by_column': TorrentSearchOrderByColumn;
    'order_by_direction': OrderByDirection;
    'page': number;
    'page_size': number;
    'series_id'?: number | null;
    'title_group_include_empty_groups': boolean;
    'title_group_name'?: string | null;
    'torrent_created_by_id'?: number | null;
    'torrent_reported'?: boolean | null;
    'torrent_snatched_by_id'?: number | null;
    'torrent_staff_checked'?: boolean | null;
}



export const TorrentSearchOrderByColumn = {
    TorrentCreatedAt: 'torrent_created_at',
    TorrentSize: 'torrent_size',
    TorrentSnatchedAt: 'torrent_snatched_at',
    TitleGroupOriginalReleaseDate: 'title_group_original_release_date'
} as const;

export type TorrentSearchOrderByColumn = typeof TorrentSearchOrderByColumn[keyof typeof TorrentSearchOrderByColumn];


export interface TorrentToDelete {
    'displayed_reason'?: string | null;
    'id': number;
    'reason': string;
}
export interface UnauthorizedAccess {
    'created_at': string;
    'id': number;
    'missing_permission': UserPermission;
    'path': string;
    'user': UserLiteAvatar;
}



export const UnauthorizedAccessSortByColumn = {
    CreatedAt: 'created_at',
    MissingPermission: 'missing_permission'
} as const;

export type UnauthorizedAccessSortByColumn = typeof UnauthorizedAccessSortByColumn[keyof typeof UnauthorizedAccessSortByColumn];


export interface UpdateUserApplication {
    'status': UserApplicationStatus;
    'user_application_id': number;
}


export interface UpdatedUserPermissions {
    'permissions': Array<UserPermission>;
}
export interface UploadInformation {
    'announce_url': string;
}
export interface UploadedTorrent {
    'audio_bitrate': number;
    'audio_bitrate_sampling': AudioBitrateSampling;
    'audio_channels': string;
    'audio_codec': AudioCodec;
    'container': string;
    'description': string;
    'duration': number;
    'edition_group_id': number;
    'extras': string;
    'features': string;
    'languages': string;
    'mediainfo': string;
    'release_group': string;
    'release_name': string;
    'subtitle_languages': string;
    'torrent_file': File;
    'uploaded_as_anonymous': boolean;
    'video_codec': VideoCodec;
    'video_resolution': VideoResolution;
    'video_resolution_other_x': number;
    'video_resolution_other_y': number;
}


export interface User {
    'artist_comments': number;
    'avatar'?: string | null;
    'average_seeding_time': number;
    'banned': boolean;
    'bonus_points': number;
    'class_locked': boolean;
    'class_name': string;
    'collages_started': number;
    'created_at': string;
    'css_sheet_name': string;
    'description': string;
    'downloaded': number;
    'email': string;
    'forum_posts': number;
    'forum_threads': number;
    'freeleech_tokens': number;
    'id': number;
    'invitations': number;
    'invited': number;
    'last_seen': string;
    'leeching': number;
    'passkey': string;
    'password_hash': string;
    'permissions': Array<UserPermission>;
    'ratio': number;
    'real_downloaded': number;
    'real_uploaded': number;
    'registered_from_ip': string;
    'request_comments': number;
    'requests_filled': number;
    'requests_voted': number;
    'required_ratio': number;
    'seeding': number;
    'seeding_size': number;
    'snatched': number;
    'staff_note': string;
    'torrent_comments': number;
    'uploaded': number;
    'username': string;
    'warned': boolean;
}
export interface UserApplication {
    'applied_from_ip': string;
    'body': string;
    'created_at': string;
    'email': string;
    'id': number;
    'referral': string;
    'staff_note': string;
    'status': UserApplicationStatus;
}



export const UserApplicationStatus = {
    Pending: 'pending',
    Accepted: 'accepted',
    Rejected: 'rejected'
} as const;

export type UserApplicationStatus = typeof UserApplicationStatus[keyof typeof UserApplicationStatus];


export interface UserClass {
    'automatic_demotion': boolean;
    'automatic_promotion': boolean;
    'name': string;
    'new_permissions': Array<UserPermission>;
    'promotion_allowed_while_warned': boolean;
    'required_account_age_in_days': number;
    'required_downloaded': number;
    'required_forum_posts': number;
    'required_forum_posts_in_unique_threads': number;
    'required_ratio': number;
    'required_seeding_size': number;
    'required_title_group_comments': number;
    'required_torrent_snatched': number;
    'required_torrent_uploads': number;
    'required_torrent_uploads_in_unique_title_groups': number;
    'required_uploaded': number;
}
export interface UserClassChange {
    'class_name': string;
}
export interface UserClassLockStatus {
    'class_locked': boolean;
}
export interface UserCreatedAffiliatedArtist {
    'artist_id': number;
    'nickname'?: string | null;
    'roles': Array<ArtistRole>;
    'title_group_id': number;
}
export interface UserCreatedArtist {
    'description': string;
    'name': string;
    'pictures': Array<string>;
}
export interface UserCreatedCollage {
    'category': CollageCategory;
    'cover'?: string | null;
    'description': string;
    'name': string;
    'tags': Array<string>;
}


export interface UserCreatedCollageEntry {
    'collage_id': number;
    'note'?: string | null;
    'title_group_id': number;
}
export interface UserCreatedConversation {
    'first_message': UserCreatedConversationMessage;
    'receiver_id': number;
    'subject': string;
}
export interface UserCreatedConversationMessage {
    'content': string;
    'conversation_id': number;
}
export interface UserCreatedCssSheet {
    'css': string;
    'name': string;
    'preview_image_url': string;
}
export interface UserCreatedDonation {
    'amount': number;
    'donated_at'?: string | null;
    'donated_by_id': number;
    'note'?: string | null;
}
export interface UserCreatedEditionGroup {
    'additional_information': { [key: string]: string; };
    'covers': Array<string>;
    'description'?: string | null;
    'distributor'?: string | null;
    'external_links': Array<string>;
    'name'?: string | null;
    'release_date': string;
    'source'?: Source | null;
    'title_group_id': number;
}


export interface UserCreatedForumCategory {
    'name': string;
}
export interface UserCreatedForumPost {
    'content': string;
    'forum_thread_id': number;
}
export interface UserCreatedForumSubCategory {
    'forum_category_id': number;
    'name': string;
}
export interface UserCreatedForumThread {
    'first_post': UserCreatedForumPost;
    'forum_sub_category_id': number;
    'name': string;
}
export interface UserCreatedGift {
    'bonus_points': number;
    'freeleech_tokens': number;
    'message': string;
    'receiver_id': number;
}
export interface UserCreatedMasterGroup {
    'name'?: string | null;
}
export interface UserCreatedSeries {
    'banners': Array<string>;
    'covers': Array<string>;
    'description': string;
    'name': string;
    'tags': Array<string>;
}
export interface UserCreatedStaffPm {
    'first_message': UserCreatedStaffPmMessage;
    'subject': string;
}
export interface UserCreatedStaffPmMessage {
    'content': string;
    'staff_pm_id': number;
}
export interface UserCreatedTitleGroup {
    'affiliated_artists': Array<UserCreatedAffiliatedArtist>;
    'category'?: TitleGroupCategory | null;
    'content_type': ContentType;
    'country_from'?: string | null;
    'covers': Array<string>;
    'description': string;
    'embedded_links': { [key: string]: { [key: string]: string; }; };
    'external_links': Array<string>;
    'master_group_id'?: number | null;
    'name': string;
    'name_aliases': Array<string>;
    'original_language'?: Language | null;
    'original_release_date': string;
    'platform'?: Platform | null;
    'screenshots': Array<string>;
    'series_id'?: number | null;
    'tagline'?: string | null;
    'tags': Array<string>;
}


export interface UserCreatedTitleGroupBookmark {
    'description'?: string | null;
    'title_group_id': number;
}
export interface UserCreatedTitleGroupComment {
    'answers_to_comment_id'?: number | null;
    'content': string;
    'refers_to_torrent_id'?: number | null;
    'title_group_id': number;
}
export interface UserCreatedTitleGroupTag {
    'name': string;
}
export interface UserCreatedTorrentReport {
    'description': string;
    'reported_torrent_id': number;
}
export interface UserCreatedTorrentRequest {
    'audio_bitrate_sampling': Array<AudioBitrateSampling>;
    'audio_channels': Array<AudioChannels>;
    'audio_codec': Array<AudioCodec>;
    'container': Array<string>;
    'description'?: string | null;
    'edition_name'?: string | null;
    'features': Array<Features>;
    'initial_vote': UserCreatedTorrentRequestVote;
    'languages': Array<Language>;
    'release_group'?: string | null;
    'source': Array<Source>;
    'subtitle_languages': Array<Language>;
    'title_group_id': number;
    'video_codec': Array<VideoCodec>;
    'video_resolution': Array<VideoResolution>;
    'video_resolution_other_x'?: number | null;
    'video_resolution_other_y'?: number | null;
}
export interface UserCreatedTorrentRequestComment {
    'content': string;
    'torrent_request_id': number;
}
export interface UserCreatedTorrentRequestVote {
    'bounty_bonus_points': number;
    'bounty_upload': number;
    'torrent_request_id': number;
}
export interface UserCreatedUserApplication {
    'body': string;
    'email': string;
    'referral': string;
}
export interface UserCreatedUserClass {
    'automatic_demotion': boolean;
    'automatic_promotion': boolean;
    'name': string;
    'new_permissions': Array<UserPermission>;
    'promotion_allowed_while_warned': boolean;
    'required_account_age_in_days': number;
    'required_downloaded': number;
    'required_forum_posts': number;
    'required_forum_posts_in_unique_threads': number;
    'required_ratio': number;
    'required_seeding_size': number;
    'required_title_group_comments': number;
    'required_torrent_snatched': number;
    'required_torrent_uploads': number;
    'required_torrent_uploads_in_unique_title_groups': number;
    'required_uploaded': number;
}
export interface UserCreatedUserWarning {
    'ban': boolean;
    'expires_at'?: string | null;
    'reason': string;
    'user_id': number;
}
export interface UserCreatedWikiArticle {
    'body': string;
    'title': string;
}
export interface UserLite {
    'banned': boolean;
    'id': number;
    'username': string;
    'warned': boolean;
}
export interface UserLiteAvatar {
    'avatar'?: string | null;
    'banned': boolean;
    'id': number;
    'username': string;
    'warned': boolean;
}

export const UserPermission = {
    UploadTorrent: 'upload_torrent',
    DownloadTorrent: 'download_torrent',
    CreateTorrentRequest: 'create_torrent_request',
    ImmuneActivityPruning: 'immune_activity_pruning',
    EditTitleGroup: 'edit_title_group',
    EditTitleGroupComment: 'edit_title_group_comment',
    EditEditionGroup: 'edit_edition_group',
    EditTorrent: 'edit_torrent',
    EditArtist: 'edit_artist',
    EditCollage: 'edit_collage',
    EditSeries: 'edit_series',
    EditTorrentRequest: 'edit_torrent_request',
    EditForumPost: 'edit_forum_post',
    EditForumThread: 'edit_forum_thread',
    EditForumSubCategory: 'edit_forum_sub_category',
    EditForumCategory: 'edit_forum_category',
    CreateForumCategory: 'create_forum_category',
    CreateForumSubCategory: 'create_forum_sub_category',
    CreateForumThread: 'create_forum_thread',
    CreateForumPost: 'create_forum_post',
    SendPm: 'send_pm',
    CreateCssSheet: 'create_css_sheet',
    EditCssSheet: 'edit_css_sheet',
    ReadStaffPm: 'read_staff_pm',
    ReplyStaffPm: 'reply_staff_pm',
    ResolveStaffPm: 'resolve_staff_pm',
    UnresolveStaffPm: 'unresolve_staff_pm',
    DeleteTitleGroupTag: 'delete_title_group_tag',
    EditTitleGroupTag: 'edit_title_group_tag',
    DeleteTorrent: 'delete_torrent',
    GetUserApplication: 'get_user_application',
    UpdateUserApplication: 'update_user_application',
    WarnUser: 'warn_user',
    BanUser: 'ban_user',
    EditUser: 'edit_user',
    CreateWikiArticle: 'create_wiki_article',
    EditWikiArticle: 'edit_wiki_article',
    CreateUserClass: 'create_user_class',
    EditUserClass: 'edit_user_class',
    DeleteUserClass: 'delete_user_class',
    EditUserPermissions: 'edit_user_permissions',
    LockUserClass: 'lock_user_class',
    ChangeUserClass: 'change_user_class',
    EditArcadiaSettings: 'edit_arcadia_settings',
    CreateDonation: 'create_donation',
    EditDonation: 'edit_donation',
    DeleteDonation: 'delete_donation',
    SearchDonation: 'search_donation',
    SearchUnauthorizedAccess: 'search_unauthorized_access'
} as const;

export type UserPermission = typeof UserPermission[keyof typeof UserPermission];


export interface UserSettings {
    'css_sheet_name': string;
}
export interface UserWarning {
    'ban': boolean;
    'created_at': string;
    'created_by_id': number;
    'expires_at'?: string | null;
    'id': number;
    'reason': string;
    'user_id': number;
}

export const VideoCodec = {
    Mpeg1: 'mpeg1',
    Mpeg2: 'mpeg2',
    Xvid: 'Xvid',
    DivX: 'divX',
    H264: 'h264',
    H265: 'h265',
    Vc1: 'vc-1',
    Vp9: 'vp9',
    Bd50: 'BD50',
    Uhd100: 'UHD100',
    Dvd5: 'DVD5',
    Dvd9: 'DVD9'
} as const;

export type VideoCodec = typeof VideoCodec[keyof typeof VideoCodec];



export const VideoResolution = {
    Other: 'Other',
    _480p: '480p',
    _480i: '480i',
    _576i: '576i',
    _576p: '576p',
    _720p: '720p',
    _1080p: '1080p',
    _1080i: '1080i',
    _1440p: '1440p',
    _2160p: '2160p',
    _4320p: '4320p'
} as const;

export type VideoResolution = typeof VideoResolution[keyof typeof VideoResolution];


export interface WikiArticle {
    'body': string;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'title': string;
    'updated_at': string;
    'updated_by_id': number;
}


/**
 * AffiliatedArtistApi - axios parameter creator
 */
export const AffiliatedArtistApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<UserCreatedAffiliatedArtist>} userCreatedAffiliatedArtist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtistAffiliation: async (userCreatedAffiliatedArtist: Array<UserCreatedAffiliatedArtist>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedAffiliatedArtist' is not null or undefined
            assertParamExists('createArtistAffiliation', 'userCreatedAffiliatedArtist', userCreatedAffiliatedArtist)
            const localVarPath = `/api/affiliated-artists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedAffiliatedArtist, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtistAffiliation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/affiliated-artists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AffiliatedArtistApi - functional programming interface
 */
export const AffiliatedArtistApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AffiliatedArtistApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<UserCreatedAffiliatedArtist>} userCreatedAffiliatedArtist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtistAffiliation(userCreatedAffiliatedArtist: Array<UserCreatedAffiliatedArtist>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AffiliatedArtistHierarchy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArtistAffiliation(userCreatedAffiliatedArtist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AffiliatedArtistApi.createArtistAffiliation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtistAffiliation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtistAffiliation(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AffiliatedArtistApi.deleteArtistAffiliation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AffiliatedArtistApi - factory interface
 */
export const AffiliatedArtistApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AffiliatedArtistApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<UserCreatedAffiliatedArtist>} userCreatedAffiliatedArtist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtistAffiliation(userCreatedAffiliatedArtist: Array<UserCreatedAffiliatedArtist>, options?: RawAxiosRequestConfig): AxiosPromise<Array<AffiliatedArtistHierarchy>> {
            return localVarFp.createArtistAffiliation(userCreatedAffiliatedArtist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtistAffiliation(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteArtistAffiliation(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AffiliatedArtistApi - object-oriented interface
 */
export class AffiliatedArtistApi extends BaseAPI {
    /**
     * 
     * @param {Array<UserCreatedAffiliatedArtist>} userCreatedAffiliatedArtist 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createArtistAffiliation(userCreatedAffiliatedArtist: Array<UserCreatedAffiliatedArtist>, options?: RawAxiosRequestConfig) {
        return AffiliatedArtistApiFp(this.configuration).createArtistAffiliation(userCreatedAffiliatedArtist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteArtistAffiliation(options?: RawAxiosRequestConfig) {
        return AffiliatedArtistApiFp(this.configuration).deleteArtistAffiliation(options).then((request) => request(this.axios, this.basePath));
    }
}


export const affiliatedArtistApi = new AffiliatedArtistApi(undefined, undefined, globalAxios);



export const createArtistAffiliation = async (userCreatedAffiliatedArtist: Array<UserCreatedAffiliatedArtist>, options?: RawAxiosRequestConfig): Promise<Array<AffiliatedArtistHierarchy>> => {
    const response = await affiliatedArtistApi.createArtistAffiliation(userCreatedAffiliatedArtist, options);
    return response.data;
};


export const deleteArtistAffiliation = async (options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await affiliatedArtistApi.deleteArtistAffiliation(options);
    return response.data;
};


/**
 * ArcadiaSettingsApi - axios parameter creator
 */
export const ArcadiaSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArcadiaSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/arcadia-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ArcadiaSettings} arcadiaSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArcadiaSettings: async (arcadiaSettings: ArcadiaSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arcadiaSettings' is not null or undefined
            assertParamExists('updateArcadiaSettings', 'arcadiaSettings', arcadiaSettings)
            const localVarPath = `/api/arcadia-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(arcadiaSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArcadiaSettingsApi - functional programming interface
 */
export const ArcadiaSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArcadiaSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArcadiaSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArcadiaSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArcadiaSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArcadiaSettingsApi.getArcadiaSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ArcadiaSettings} arcadiaSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArcadiaSettings(arcadiaSettings: ArcadiaSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArcadiaSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArcadiaSettings(arcadiaSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArcadiaSettingsApi.updateArcadiaSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ArcadiaSettingsApi - factory interface
 */
export const ArcadiaSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArcadiaSettingsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArcadiaSettings(options?: RawAxiosRequestConfig): AxiosPromise<ArcadiaSettings> {
            return localVarFp.getArcadiaSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ArcadiaSettings} arcadiaSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArcadiaSettings(arcadiaSettings: ArcadiaSettings, options?: RawAxiosRequestConfig): AxiosPromise<ArcadiaSettings> {
            return localVarFp.updateArcadiaSettings(arcadiaSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArcadiaSettingsApi - object-oriented interface
 */
export class ArcadiaSettingsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getArcadiaSettings(options?: RawAxiosRequestConfig) {
        return ArcadiaSettingsApiFp(this.configuration).getArcadiaSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ArcadiaSettings} arcadiaSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateArcadiaSettings(arcadiaSettings: ArcadiaSettings, options?: RawAxiosRequestConfig) {
        return ArcadiaSettingsApiFp(this.configuration).updateArcadiaSettings(arcadiaSettings, options).then((request) => request(this.axios, this.basePath));
    }
}


export const arcadiaSettingsApi = new ArcadiaSettingsApi(undefined, undefined, globalAxios);



export const getArcadiaSettings = async (options?: RawAxiosRequestConfig): Promise<ArcadiaSettings> => {
    const response = await arcadiaSettingsApi.getArcadiaSettings(options);
    return response.data;
};


export const updateArcadiaSettings = async (arcadiaSettings: ArcadiaSettings, options?: RawAxiosRequestConfig): Promise<ArcadiaSettings> => {
    const response = await arcadiaSettingsApi.updateArcadiaSettings(arcadiaSettings, options);
    return response.data;
};


/**
 * ArtistApi - axios parameter creator
 */
export const ArtistApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<UserCreatedArtist>} userCreatedArtist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtists: async (userCreatedArtist: Array<UserCreatedArtist>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedArtist' is not null or undefined
            assertParamExists('createArtists', 'userCreatedArtist', userCreatedArtist)
            const localVarPath = `/api/artists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedArtist, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditedArtist} editedArtist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editArtist: async (editedArtist: EditedArtist, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editedArtist' is not null or undefined
            assertParamExists('editArtist', 'editedArtist', editedArtist)
            const localVarPath = `/api/artists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedArtist, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistPublications: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getArtistPublications', 'id', id)
            const localVarPath = `/api/artists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtistApi - functional programming interface
 */
export const ArtistApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtistApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<UserCreatedArtist>} userCreatedArtist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtists(userCreatedArtist: Array<UserCreatedArtist>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Artist>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArtists(userCreatedArtist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtistApi.createArtists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditedArtist} editedArtist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editArtist(editedArtist: EditedArtist, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Artist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editArtist(editedArtist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtistApi.editArtist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtistPublications(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtistAndTitleGroupsLite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtistPublications(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtistApi.getArtistPublications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ArtistApi - factory interface
 */
export const ArtistApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtistApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<UserCreatedArtist>} userCreatedArtist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtists(userCreatedArtist: Array<UserCreatedArtist>, options?: RawAxiosRequestConfig): AxiosPromise<Array<Artist>> {
            return localVarFp.createArtists(userCreatedArtist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditedArtist} editedArtist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editArtist(editedArtist: EditedArtist, options?: RawAxiosRequestConfig): AxiosPromise<Artist> {
            return localVarFp.editArtist(editedArtist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistPublications(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ArtistAndTitleGroupsLite> {
            return localVarFp.getArtistPublications(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtistApi - object-oriented interface
 */
export class ArtistApi extends BaseAPI {
    /**
     * 
     * @param {Array<UserCreatedArtist>} userCreatedArtist 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createArtists(userCreatedArtist: Array<UserCreatedArtist>, options?: RawAxiosRequestConfig) {
        return ArtistApiFp(this.configuration).createArtists(userCreatedArtist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditedArtist} editedArtist 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editArtist(editedArtist: EditedArtist, options?: RawAxiosRequestConfig) {
        return ArtistApiFp(this.configuration).editArtist(editedArtist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getArtistPublications(id: number, options?: RawAxiosRequestConfig) {
        return ArtistApiFp(this.configuration).getArtistPublications(id, options).then((request) => request(this.axios, this.basePath));
    }
}


export const artistApi = new ArtistApi(undefined, undefined, globalAxios);



export const createArtists = async (userCreatedArtist: Array<UserCreatedArtist>, options?: RawAxiosRequestConfig): Promise<Array<Artist>> => {
    const response = await artistApi.createArtists(userCreatedArtist, options);
    return response.data;
};


export const editArtist = async (editedArtist: EditedArtist, options?: RawAxiosRequestConfig): Promise<Artist> => {
    const response = await artistApi.editArtist(editedArtist, options);
    return response.data;
};


export const getArtistPublications = async (id: number, options?: RawAxiosRequestConfig): Promise<ArtistAndTitleGroupsLite> => {
    const response = await artistApi.getArtistPublications(id, options);
    return response.data;
};


/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Login} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (login: Login, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            assertParamExists('login', 'login', login)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(login, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RefreshToken} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshToken: RefreshToken, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshToken' is not null or undefined
            assertParamExists('refreshToken', 'refreshToken', refreshToken)
            const localVarPath = `/api/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Register} register 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (register: Register, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'register' is not null or undefined
            assertParamExists('register', 'register', register)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(register, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Login} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(login: Login, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(login, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RefreshToken} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshToken: RefreshToken, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Register} register 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(register: Register, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(register, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {Login} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(login: Login, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.login(login, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RefreshToken} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshToken: RefreshToken, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.refreshToken(refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Register} register 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(register: Register, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.register(register, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {Login} login 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(login: Login, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RefreshToken} refreshToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refreshToken(refreshToken: RefreshToken, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshToken(refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Register} register 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public register(register: Register, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(register, options).then((request) => request(this.axios, this.basePath));
    }
}


export const authApi = new AuthApi(undefined, undefined, globalAxios);



export const login = async (login: Login, options?: RawAxiosRequestConfig): Promise<LoginResponse> => {
    const response = await authApi.login(login, options);
    return response.data;
};


export const refreshToken = async (refreshToken: RefreshToken, options?: RawAxiosRequestConfig): Promise<LoginResponse> => {
    const response = await authApi.refreshToken(refreshToken, options);
    return response.data;
};


export const register = async (register: Register, options?: RawAxiosRequestConfig): Promise<User> => {
    const response = await authApi.register(register, options);
    return response.data;
};


/**
 * BookmarkApi - axios parameter creator
 */
export const BookmarkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedTitleGroupBookmark} userCreatedTitleGroupBookmark 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTitleGroupBookmark: async (userCreatedTitleGroupBookmark: UserCreatedTitleGroupBookmark, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedTitleGroupBookmark' is not null or undefined
            assertParamExists('createTitleGroupBookmark', 'userCreatedTitleGroupBookmark', userCreatedTitleGroupBookmark)
            const localVarPath = `/api/title-group-bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedTitleGroupBookmark, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditedTitleGroupBookmark} editedTitleGroupBookmark 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTitleGroupBookmark: async (editedTitleGroupBookmark: EditedTitleGroupBookmark, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editedTitleGroupBookmark' is not null or undefined
            assertParamExists('editTitleGroupBookmark', 'editedTitleGroupBookmark', editedTitleGroupBookmark)
            const localVarPath = `/api/title-group-bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedTitleGroupBookmark, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTitleGroupBookmark: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTitleGroupBookmark', 'id', id)
            const localVarPath = `/api/title-group-bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTitleGroupBookmark: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeTitleGroupBookmark', 'id', id)
            const localVarPath = `/api/title-group-bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookmarkApi - functional programming interface
 */
export const BookmarkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookmarkApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedTitleGroupBookmark} userCreatedTitleGroupBookmark 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTitleGroupBookmark(userCreatedTitleGroupBookmark: UserCreatedTitleGroupBookmark, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TitleGroupBookmark>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTitleGroupBookmark(userCreatedTitleGroupBookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookmarkApi.createTitleGroupBookmark']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditedTitleGroupBookmark} editedTitleGroupBookmark 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editTitleGroupBookmark(editedTitleGroupBookmark: EditedTitleGroupBookmark, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TitleGroupBookmark>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editTitleGroupBookmark(editedTitleGroupBookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookmarkApi.editTitleGroupBookmark']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTitleGroupBookmark(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TitleGroupBookmark>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTitleGroupBookmark(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookmarkApi.getTitleGroupBookmark']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTitleGroupBookmark(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTitleGroupBookmark(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookmarkApi.removeTitleGroupBookmark']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BookmarkApi - factory interface
 */
export const BookmarkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookmarkApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedTitleGroupBookmark} userCreatedTitleGroupBookmark 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTitleGroupBookmark(userCreatedTitleGroupBookmark: UserCreatedTitleGroupBookmark, options?: RawAxiosRequestConfig): AxiosPromise<TitleGroupBookmark> {
            return localVarFp.createTitleGroupBookmark(userCreatedTitleGroupBookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditedTitleGroupBookmark} editedTitleGroupBookmark 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTitleGroupBookmark(editedTitleGroupBookmark: EditedTitleGroupBookmark, options?: RawAxiosRequestConfig): AxiosPromise<TitleGroupBookmark> {
            return localVarFp.editTitleGroupBookmark(editedTitleGroupBookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTitleGroupBookmark(id: number, options?: RawAxiosRequestConfig): AxiosPromise<TitleGroupBookmark> {
            return localVarFp.getTitleGroupBookmark(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTitleGroupBookmark(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeTitleGroupBookmark(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookmarkApi - object-oriented interface
 */
export class BookmarkApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedTitleGroupBookmark} userCreatedTitleGroupBookmark 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTitleGroupBookmark(userCreatedTitleGroupBookmark: UserCreatedTitleGroupBookmark, options?: RawAxiosRequestConfig) {
        return BookmarkApiFp(this.configuration).createTitleGroupBookmark(userCreatedTitleGroupBookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditedTitleGroupBookmark} editedTitleGroupBookmark 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editTitleGroupBookmark(editedTitleGroupBookmark: EditedTitleGroupBookmark, options?: RawAxiosRequestConfig) {
        return BookmarkApiFp(this.configuration).editTitleGroupBookmark(editedTitleGroupBookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTitleGroupBookmark(id: number, options?: RawAxiosRequestConfig) {
        return BookmarkApiFp(this.configuration).getTitleGroupBookmark(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public removeTitleGroupBookmark(id: number, options?: RawAxiosRequestConfig) {
        return BookmarkApiFp(this.configuration).removeTitleGroupBookmark(id, options).then((request) => request(this.axios, this.basePath));
    }
}


export const bookmarkApi = new BookmarkApi(undefined, undefined, globalAxios);



export const createTitleGroupBookmark = async (userCreatedTitleGroupBookmark: UserCreatedTitleGroupBookmark, options?: RawAxiosRequestConfig): Promise<TitleGroupBookmark> => {
    const response = await bookmarkApi.createTitleGroupBookmark(userCreatedTitleGroupBookmark, options);
    return response.data;
};


export const editTitleGroupBookmark = async (editedTitleGroupBookmark: EditedTitleGroupBookmark, options?: RawAxiosRequestConfig): Promise<TitleGroupBookmark> => {
    const response = await bookmarkApi.editTitleGroupBookmark(editedTitleGroupBookmark, options);
    return response.data;
};


export const getTitleGroupBookmark = async (id: number, options?: RawAxiosRequestConfig): Promise<TitleGroupBookmark> => {
    const response = await bookmarkApi.getTitleGroupBookmark(id, options);
    return response.data;
};


export const removeTitleGroupBookmark = async (id: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await bookmarkApi.removeTitleGroupBookmark(id, options);
    return response.data;
};


/**
 * CollagesApi - axios parameter creator
 */
export const CollagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedCollage} userCreatedCollage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollage: async (userCreatedCollage: UserCreatedCollage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedCollage' is not null or undefined
            assertParamExists('createCollage', 'userCreatedCollage', userCreatedCollage)
            const localVarPath = `/api/collages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedCollage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollage: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCollage', 'id', id)
            const localVarPath = `/api/collages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} titleGroupIncludeEmptyGroups 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {TorrentSearchOrderByColumn} orderByColumn 
         * @param {OrderByDirection} orderByDirection 
         * @param {string | null} [titleGroupName] 
         * @param {boolean | null} [torrentReported] 
         * @param {boolean | null} [torrentStaffChecked] 
         * @param {number | null} [torrentCreatedById] 
         * @param {number | null} [torrentSnatchedById] 
         * @param {number | null} [artistId] 
         * @param {number | null} [collageId] 
         * @param {number | null} [seriesId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollageEntries: async (titleGroupIncludeEmptyGroups: boolean, page: number, pageSize: number, orderByColumn: TorrentSearchOrderByColumn, orderByDirection: OrderByDirection, titleGroupName?: string | null, torrentReported?: boolean | null, torrentStaffChecked?: boolean | null, torrentCreatedById?: number | null, torrentSnatchedById?: number | null, artistId?: number | null, collageId?: number | null, seriesId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'titleGroupIncludeEmptyGroups' is not null or undefined
            assertParamExists('getCollageEntries', 'titleGroupIncludeEmptyGroups', titleGroupIncludeEmptyGroups)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getCollageEntries', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getCollageEntries', 'pageSize', pageSize)
            // verify required parameter 'orderByColumn' is not null or undefined
            assertParamExists('getCollageEntries', 'orderByColumn', orderByColumn)
            // verify required parameter 'orderByDirection' is not null or undefined
            assertParamExists('getCollageEntries', 'orderByDirection', orderByDirection)
            const localVarPath = `/api/collages/entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (titleGroupName !== undefined) {
                localVarQueryParameter['title_group_name'] = titleGroupName;
            }

            if (titleGroupIncludeEmptyGroups !== undefined) {
                localVarQueryParameter['title_group_include_empty_groups'] = titleGroupIncludeEmptyGroups;
            }

            if (torrentReported !== undefined) {
                localVarQueryParameter['torrent_reported'] = torrentReported;
            }

            if (torrentStaffChecked !== undefined) {
                localVarQueryParameter['torrent_staff_checked'] = torrentStaffChecked;
            }

            if (torrentCreatedById !== undefined) {
                localVarQueryParameter['torrent_created_by_id'] = torrentCreatedById;
            }

            if (torrentSnatchedById !== undefined) {
                localVarQueryParameter['torrent_snatched_by_id'] = torrentSnatchedById;
            }

            if (artistId !== undefined) {
                localVarQueryParameter['artist_id'] = artistId;
            }

            if (collageId !== undefined) {
                localVarQueryParameter['collage_id'] = collageId;
            }

            if (seriesId !== undefined) {
                localVarQueryParameter['series_id'] = seriesId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (orderByColumn !== undefined) {
                localVarQueryParameter['order_by_column'] = orderByColumn;
            }

            if (orderByDirection !== undefined) {
                localVarQueryParameter['order_by_direction'] = orderByDirection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<UserCreatedCollageEntry>} userCreatedCollageEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertsEntriesIntoACollage: async (userCreatedCollageEntry: Array<UserCreatedCollageEntry>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedCollageEntry' is not null or undefined
            assertParamExists('insertsEntriesIntoACollage', 'userCreatedCollageEntry', userCreatedCollageEntry)
            const localVarPath = `/api/collages/entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedCollageEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollagesApi - functional programming interface
 */
export const CollagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedCollage} userCreatedCollage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollage(userCreatedCollage: UserCreatedCollage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollage(userCreatedCollage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollagesApi.createCollage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollage(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollage(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollagesApi.getCollage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} titleGroupIncludeEmptyGroups 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {TorrentSearchOrderByColumn} orderByColumn 
         * @param {OrderByDirection} orderByDirection 
         * @param {string | null} [titleGroupName] 
         * @param {boolean | null} [torrentReported] 
         * @param {boolean | null} [torrentStaffChecked] 
         * @param {number | null} [torrentCreatedById] 
         * @param {number | null} [torrentSnatchedById] 
         * @param {number | null} [artistId] 
         * @param {number | null} [collageId] 
         * @param {number | null} [seriesId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollageEntries(titleGroupIncludeEmptyGroups: boolean, page: number, pageSize: number, orderByColumn: TorrentSearchOrderByColumn, orderByDirection: OrderByDirection, titleGroupName?: string | null, torrentReported?: boolean | null, torrentStaffChecked?: boolean | null, torrentCreatedById?: number | null, torrentSnatchedById?: number | null, artistId?: number | null, collageId?: number | null, seriesId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResultsTitleGroupHierarchyLite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollageEntries(titleGroupIncludeEmptyGroups, page, pageSize, orderByColumn, orderByDirection, titleGroupName, torrentReported, torrentStaffChecked, torrentCreatedById, torrentSnatchedById, artistId, collageId, seriesId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollagesApi.getCollageEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<UserCreatedCollageEntry>} userCreatedCollageEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertsEntriesIntoACollage(userCreatedCollageEntry: Array<UserCreatedCollageEntry>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CollageEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertsEntriesIntoACollage(userCreatedCollageEntry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollagesApi.insertsEntriesIntoACollage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollagesApi - factory interface
 */
export const CollagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollagesApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedCollage} userCreatedCollage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollage(userCreatedCollage: UserCreatedCollage, options?: RawAxiosRequestConfig): AxiosPromise<Collage> {
            return localVarFp.createCollage(userCreatedCollage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollage(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Collage> {
            return localVarFp.getCollage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} titleGroupIncludeEmptyGroups 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {TorrentSearchOrderByColumn} orderByColumn 
         * @param {OrderByDirection} orderByDirection 
         * @param {string | null} [titleGroupName] 
         * @param {boolean | null} [torrentReported] 
         * @param {boolean | null} [torrentStaffChecked] 
         * @param {number | null} [torrentCreatedById] 
         * @param {number | null} [torrentSnatchedById] 
         * @param {number | null} [artistId] 
         * @param {number | null} [collageId] 
         * @param {number | null} [seriesId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollageEntries(titleGroupIncludeEmptyGroups: boolean, page: number, pageSize: number, orderByColumn: TorrentSearchOrderByColumn, orderByDirection: OrderByDirection, titleGroupName?: string | null, torrentReported?: boolean | null, torrentStaffChecked?: boolean | null, torrentCreatedById?: number | null, torrentSnatchedById?: number | null, artistId?: number | null, collageId?: number | null, seriesId?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResultsTitleGroupHierarchyLite> {
            return localVarFp.getCollageEntries(titleGroupIncludeEmptyGroups, page, pageSize, orderByColumn, orderByDirection, titleGroupName, torrentReported, torrentStaffChecked, torrentCreatedById, torrentSnatchedById, artistId, collageId, seriesId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<UserCreatedCollageEntry>} userCreatedCollageEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertsEntriesIntoACollage(userCreatedCollageEntry: Array<UserCreatedCollageEntry>, options?: RawAxiosRequestConfig): AxiosPromise<Array<CollageEntry>> {
            return localVarFp.insertsEntriesIntoACollage(userCreatedCollageEntry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollagesApi - object-oriented interface
 */
export class CollagesApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedCollage} userCreatedCollage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCollage(userCreatedCollage: UserCreatedCollage, options?: RawAxiosRequestConfig) {
        return CollagesApiFp(this.configuration).createCollage(userCreatedCollage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCollage(id: number, options?: RawAxiosRequestConfig) {
        return CollagesApiFp(this.configuration).getCollage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} titleGroupIncludeEmptyGroups 
     * @param {number} page 
     * @param {number} pageSize 
     * @param {TorrentSearchOrderByColumn} orderByColumn 
     * @param {OrderByDirection} orderByDirection 
     * @param {string | null} [titleGroupName] 
     * @param {boolean | null} [torrentReported] 
     * @param {boolean | null} [torrentStaffChecked] 
     * @param {number | null} [torrentCreatedById] 
     * @param {number | null} [torrentSnatchedById] 
     * @param {number | null} [artistId] 
     * @param {number | null} [collageId] 
     * @param {number | null} [seriesId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCollageEntries(titleGroupIncludeEmptyGroups: boolean, page: number, pageSize: number, orderByColumn: TorrentSearchOrderByColumn, orderByDirection: OrderByDirection, titleGroupName?: string | null, torrentReported?: boolean | null, torrentStaffChecked?: boolean | null, torrentCreatedById?: number | null, torrentSnatchedById?: number | null, artistId?: number | null, collageId?: number | null, seriesId?: number | null, options?: RawAxiosRequestConfig) {
        return CollagesApiFp(this.configuration).getCollageEntries(titleGroupIncludeEmptyGroups, page, pageSize, orderByColumn, orderByDirection, titleGroupName, torrentReported, torrentStaffChecked, torrentCreatedById, torrentSnatchedById, artistId, collageId, seriesId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<UserCreatedCollageEntry>} userCreatedCollageEntry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public insertsEntriesIntoACollage(userCreatedCollageEntry: Array<UserCreatedCollageEntry>, options?: RawAxiosRequestConfig) {
        return CollagesApiFp(this.configuration).insertsEntriesIntoACollage(userCreatedCollageEntry, options).then((request) => request(this.axios, this.basePath));
    }
}


export const collagesApi = new CollagesApi(undefined, undefined, globalAxios);



export const createCollage = async (userCreatedCollage: UserCreatedCollage, options?: RawAxiosRequestConfig): Promise<Collage> => {
    const response = await collagesApi.createCollage(userCreatedCollage, options);
    return response.data;
};


export const getCollage = async (id: number, options?: RawAxiosRequestConfig): Promise<Collage> => {
    const response = await collagesApi.getCollage(id, options);
    return response.data;
};

export interface GetCollageEntriesRequest {
    /**  */
    'title_group_include_empty_groups': boolean;
    /**  */
    'page': number;
    /**  */
    'page_size': number;
    /**  */
    'order_by_column': TorrentSearchOrderByColumn;
    /**  */
    'order_by_direction': OrderByDirection;
    /**  */
    'title_group_name'?: string | null;
    /**  */
    'torrent_reported'?: boolean | null;
    /**  */
    'torrent_staff_checked'?: boolean | null;
    /**  */
    'torrent_created_by_id'?: number | null;
    /**  */
    'torrent_snatched_by_id'?: number | null;
    /**  */
    'artist_id'?: number | null;
    /**  */
    'collage_id'?: number | null;
    /**  */
    'series_id'?: number | null;
}


export const getCollageEntries = async (requestParameters: GetCollageEntriesRequest, options?: RawAxiosRequestConfig): Promise<PaginatedResultsTitleGroupHierarchyLite> => {
    const response = await collagesApi.getCollageEntries(requestParameters['title_group_include_empty_groups']!, requestParameters['page']!, requestParameters['page_size']!, requestParameters['order_by_column']!, requestParameters['order_by_direction']!, requestParameters['title_group_name']!, requestParameters['torrent_reported']!, requestParameters['torrent_staff_checked']!, requestParameters['torrent_created_by_id']!, requestParameters['torrent_snatched_by_id']!, requestParameters['artist_id']!, requestParameters['collage_id']!, requestParameters['series_id']!, options);
    return response.data;
};


export const insertsEntriesIntoACollage = async (userCreatedCollageEntry: Array<UserCreatedCollageEntry>, options?: RawAxiosRequestConfig): Promise<Array<CollageEntry>> => {
    const response = await collagesApi.insertsEntriesIntoACollage(userCreatedCollageEntry, options);
    return response.data;
};


/**
 * ConversationApi - axios parameter creator
 */
export const ConversationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedConversation} userCreatedConversation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversation: async (userCreatedConversation: UserCreatedConversation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedConversation' is not null or undefined
            assertParamExists('createConversation', 'userCreatedConversation', userCreatedConversation)
            const localVarPath = `/api/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedConversation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreatedConversationMessage} userCreatedConversationMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationMessage: async (userCreatedConversationMessage: UserCreatedConversationMessage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedConversationMessage' is not null or undefined
            assertParamExists('createConversationMessage', 'userCreatedConversationMessage', userCreatedConversationMessage)
            const localVarPath = `/api/conversations/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedConversationMessage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConversation', 'id', id)
            const localVarPath = `/api/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationApi - functional programming interface
 */
export const ConversationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConversationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedConversation} userCreatedConversation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversation(userCreatedConversation: UserCreatedConversation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Conversation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConversation(userCreatedConversation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationApi.createConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreatedConversationMessage} userCreatedConversationMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationMessage(userCreatedConversationMessage: UserCreatedConversationMessage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConversationMessage(userCreatedConversationMessage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationApi.createConversationMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversation(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationHierarchy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationApi.getConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConversationApi - factory interface
 */
export const ConversationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConversationApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedConversation} userCreatedConversation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversation(userCreatedConversation: UserCreatedConversation, options?: RawAxiosRequestConfig): AxiosPromise<Conversation> {
            return localVarFp.createConversation(userCreatedConversation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreatedConversationMessage} userCreatedConversationMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationMessage(userCreatedConversationMessage: UserCreatedConversationMessage, options?: RawAxiosRequestConfig): AxiosPromise<ConversationMessage> {
            return localVarFp.createConversationMessage(userCreatedConversationMessage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ConversationHierarchy> {
            return localVarFp.getConversation(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationApi - object-oriented interface
 */
export class ConversationApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedConversation} userCreatedConversation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createConversation(userCreatedConversation: UserCreatedConversation, options?: RawAxiosRequestConfig) {
        return ConversationApiFp(this.configuration).createConversation(userCreatedConversation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreatedConversationMessage} userCreatedConversationMessage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createConversationMessage(userCreatedConversationMessage: UserCreatedConversationMessage, options?: RawAxiosRequestConfig) {
        return ConversationApiFp(this.configuration).createConversationMessage(userCreatedConversationMessage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConversation(id: number, options?: RawAxiosRequestConfig) {
        return ConversationApiFp(this.configuration).getConversation(id, options).then((request) => request(this.axios, this.basePath));
    }
}


export const conversationApi = new ConversationApi(undefined, undefined, globalAxios);



export const createConversation = async (userCreatedConversation: UserCreatedConversation, options?: RawAxiosRequestConfig): Promise<Conversation> => {
    const response = await conversationApi.createConversation(userCreatedConversation, options);
    return response.data;
};


export const createConversationMessage = async (userCreatedConversationMessage: UserCreatedConversationMessage, options?: RawAxiosRequestConfig): Promise<ConversationMessage> => {
    const response = await conversationApi.createConversationMessage(userCreatedConversationMessage, options);
    return response.data;
};


export const getConversation = async (id: number, options?: RawAxiosRequestConfig): Promise<ConversationHierarchy> => {
    const response = await conversationApi.getConversation(id, options);
    return response.data;
};


/**
 * CssSheetApi - axios parameter creator
 */
export const CssSheetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedCssSheet} userCreatedCssSheet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCSSSheet: async (userCreatedCssSheet: UserCreatedCssSheet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedCssSheet' is not null or undefined
            assertParamExists('createCSSSheet', 'userCreatedCssSheet', userCreatedCssSheet)
            const localVarPath = `/api/css-sheets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedCssSheet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditedCssSheet} editedCssSheet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCSSSheet: async (editedCssSheet: EditedCssSheet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editedCssSheet' is not null or undefined
            assertParamExists('editCSSSheet', 'editedCssSheet', editedCssSheet)
            const localVarPath = `/api/css-sheets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedCssSheet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCSSSheet: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getCSSSheet', 'name', name)
            const localVarPath = `/api/css-sheets/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCSSSheetContent: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getCSSSheetContent', 'name', name)
            const localVarPath = `/css/{name}.css`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCSSSheets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/css-sheets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CssSheetApi - functional programming interface
 */
export const CssSheetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CssSheetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedCssSheet} userCreatedCssSheet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCSSSheet(userCreatedCssSheet: UserCreatedCssSheet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CssSheet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCSSSheet(userCreatedCssSheet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CssSheetApi.createCSSSheet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditedCssSheet} editedCssSheet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCSSSheet(editedCssSheet: EditedCssSheet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CssSheet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editCSSSheet(editedCssSheet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CssSheetApi.editCSSSheet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCSSSheet(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CssSheet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCSSSheet(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CssSheetApi.getCSSSheet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCSSSheetContent(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCSSSheetContent(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CssSheetApi.getCSSSheetContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCSSSheets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CssSheetsEnriched>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCSSSheets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CssSheetApi.getCSSSheets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CssSheetApi - factory interface
 */
export const CssSheetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CssSheetApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedCssSheet} userCreatedCssSheet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCSSSheet(userCreatedCssSheet: UserCreatedCssSheet, options?: RawAxiosRequestConfig): AxiosPromise<CssSheet> {
            return localVarFp.createCSSSheet(userCreatedCssSheet, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditedCssSheet} editedCssSheet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCSSSheet(editedCssSheet: EditedCssSheet, options?: RawAxiosRequestConfig): AxiosPromise<CssSheet> {
            return localVarFp.editCSSSheet(editedCssSheet, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCSSSheet(name: string, options?: RawAxiosRequestConfig): AxiosPromise<CssSheet> {
            return localVarFp.getCSSSheet(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCSSSheetContent(name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getCSSSheetContent(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCSSSheets(options?: RawAxiosRequestConfig): AxiosPromise<CssSheetsEnriched> {
            return localVarFp.getCSSSheets(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CssSheetApi - object-oriented interface
 */
export class CssSheetApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedCssSheet} userCreatedCssSheet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCSSSheet(userCreatedCssSheet: UserCreatedCssSheet, options?: RawAxiosRequestConfig) {
        return CssSheetApiFp(this.configuration).createCSSSheet(userCreatedCssSheet, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditedCssSheet} editedCssSheet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editCSSSheet(editedCssSheet: EditedCssSheet, options?: RawAxiosRequestConfig) {
        return CssSheetApiFp(this.configuration).editCSSSheet(editedCssSheet, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCSSSheet(name: string, options?: RawAxiosRequestConfig) {
        return CssSheetApiFp(this.configuration).getCSSSheet(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCSSSheetContent(name: string, options?: RawAxiosRequestConfig) {
        return CssSheetApiFp(this.configuration).getCSSSheetContent(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCSSSheets(options?: RawAxiosRequestConfig) {
        return CssSheetApiFp(this.configuration).getCSSSheets(options).then((request) => request(this.axios, this.basePath));
    }
}


export const cssSheetApi = new CssSheetApi(undefined, undefined, globalAxios);



export const createCSSSheet = async (userCreatedCssSheet: UserCreatedCssSheet, options?: RawAxiosRequestConfig): Promise<CssSheet> => {
    const response = await cssSheetApi.createCSSSheet(userCreatedCssSheet, options);
    return response.data;
};


export const editCSSSheet = async (editedCssSheet: EditedCssSheet, options?: RawAxiosRequestConfig): Promise<CssSheet> => {
    const response = await cssSheetApi.editCSSSheet(editedCssSheet, options);
    return response.data;
};


export const getCSSSheet = async (name: string, options?: RawAxiosRequestConfig): Promise<CssSheet> => {
    const response = await cssSheetApi.getCSSSheet(name, options);
    return response.data;
};


export const getCSSSheetContent = async (name: string, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await cssSheetApi.getCSSSheetContent(name, options);
    return response.data;
};


export const getCSSSheets = async (options?: RawAxiosRequestConfig): Promise<CssSheetsEnriched> => {
    const response = await cssSheetApi.getCSSSheets(options);
    return response.data;
};


/**
 * DonationApi - axios parameter creator
 */
export const DonationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedDonation} userCreatedDonation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDonation: async (userCreatedDonation: UserCreatedDonation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedDonation' is not null or undefined
            assertParamExists('createDonation', 'userCreatedDonation', userCreatedDonation)
            const localVarPath = `/api/donations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedDonation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeletedDonation} deletedDonation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDonation: async (deletedDonation: DeletedDonation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deletedDonation' is not null or undefined
            assertParamExists('deleteDonation', 'deletedDonation', deletedDonation)
            const localVarPath = `/api/donations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletedDonation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditedDonation} editedDonation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDonation: async (editedDonation: EditedDonation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editedDonation' is not null or undefined
            assertParamExists('editDonation', 'editedDonation', editedDonation)
            const localVarPath = `/api/donations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedDonation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {number | null} [donatedById] 
         * @param {number | null} [createdById] 
         * @param {number | null} [minAmount] 
         * @param {number | null} [maxAmount] 
         * @param {string | null} [donatedAtStart] 
         * @param {string | null} [donatedAtEnd] 
         * @param {DonationOrderBy} [orderByColumn] 
         * @param {OrderByDirection} [orderByDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDonations: async (page: number, pageSize: number, donatedById?: number | null, createdById?: number | null, minAmount?: number | null, maxAmount?: number | null, donatedAtStart?: string | null, donatedAtEnd?: string | null, orderByColumn?: DonationOrderBy, orderByDirection?: OrderByDirection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('searchDonations', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('searchDonations', 'pageSize', pageSize)
            const localVarPath = `/api/donations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (donatedById !== undefined) {
                localVarQueryParameter['donated_by_id'] = donatedById;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['created_by_id'] = createdById;
            }

            if (minAmount !== undefined) {
                localVarQueryParameter['min_amount'] = minAmount;
            }

            if (maxAmount !== undefined) {
                localVarQueryParameter['max_amount'] = maxAmount;
            }

            if (donatedAtStart !== undefined) {
                localVarQueryParameter['donated_at_start'] = donatedAtStart;
            }

            if (donatedAtEnd !== undefined) {
                localVarQueryParameter['donated_at_end'] = donatedAtEnd;
            }

            if (orderByColumn !== undefined) {
                localVarQueryParameter['order_by_column'] = orderByColumn;
            }

            if (orderByDirection !== undefined) {
                localVarQueryParameter['order_by_direction'] = orderByDirection;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DonationApi - functional programming interface
 */
export const DonationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DonationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedDonation} userCreatedDonation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDonation(userCreatedDonation: UserCreatedDonation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Donation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDonation(userCreatedDonation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationApi.createDonation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DeletedDonation} deletedDonation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDonation(deletedDonation: DeletedDonation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDonation(deletedDonation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationApi.deleteDonation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditedDonation} editedDonation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDonation(editedDonation: EditedDonation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Donation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDonation(editedDonation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationApi.editDonation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {number | null} [donatedById] 
         * @param {number | null} [createdById] 
         * @param {number | null} [minAmount] 
         * @param {number | null} [maxAmount] 
         * @param {string | null} [donatedAtStart] 
         * @param {string | null} [donatedAtEnd] 
         * @param {DonationOrderBy} [orderByColumn] 
         * @param {OrderByDirection} [orderByDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDonations(page: number, pageSize: number, donatedById?: number | null, createdById?: number | null, minAmount?: number | null, maxAmount?: number | null, donatedAtStart?: string | null, donatedAtEnd?: string | null, orderByColumn?: DonationOrderBy, orderByDirection?: OrderByDirection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchDonationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDonations(page, pageSize, donatedById, createdById, minAmount, maxAmount, donatedAtStart, donatedAtEnd, orderByColumn, orderByDirection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationApi.searchDonations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DonationApi - factory interface
 */
export const DonationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DonationApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedDonation} userCreatedDonation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDonation(userCreatedDonation: UserCreatedDonation, options?: RawAxiosRequestConfig): AxiosPromise<Donation> {
            return localVarFp.createDonation(userCreatedDonation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeletedDonation} deletedDonation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDonation(deletedDonation: DeletedDonation, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDonation(deletedDonation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditedDonation} editedDonation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDonation(editedDonation: EditedDonation, options?: RawAxiosRequestConfig): AxiosPromise<Donation> {
            return localVarFp.editDonation(editedDonation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {number | null} [donatedById] 
         * @param {number | null} [createdById] 
         * @param {number | null} [minAmount] 
         * @param {number | null} [maxAmount] 
         * @param {string | null} [donatedAtStart] 
         * @param {string | null} [donatedAtEnd] 
         * @param {DonationOrderBy} [orderByColumn] 
         * @param {OrderByDirection} [orderByDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDonations(page: number, pageSize: number, donatedById?: number | null, createdById?: number | null, minAmount?: number | null, maxAmount?: number | null, donatedAtStart?: string | null, donatedAtEnd?: string | null, orderByColumn?: DonationOrderBy, orderByDirection?: OrderByDirection, options?: RawAxiosRequestConfig): AxiosPromise<SearchDonationsResponse> {
            return localVarFp.searchDonations(page, pageSize, donatedById, createdById, minAmount, maxAmount, donatedAtStart, donatedAtEnd, orderByColumn, orderByDirection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DonationApi - object-oriented interface
 */
export class DonationApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedDonation} userCreatedDonation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createDonation(userCreatedDonation: UserCreatedDonation, options?: RawAxiosRequestConfig) {
        return DonationApiFp(this.configuration).createDonation(userCreatedDonation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeletedDonation} deletedDonation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteDonation(deletedDonation: DeletedDonation, options?: RawAxiosRequestConfig) {
        return DonationApiFp(this.configuration).deleteDonation(deletedDonation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditedDonation} editedDonation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editDonation(editedDonation: EditedDonation, options?: RawAxiosRequestConfig) {
        return DonationApiFp(this.configuration).editDonation(editedDonation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} page 
     * @param {number} pageSize 
     * @param {number | null} [donatedById] 
     * @param {number | null} [createdById] 
     * @param {number | null} [minAmount] 
     * @param {number | null} [maxAmount] 
     * @param {string | null} [donatedAtStart] 
     * @param {string | null} [donatedAtEnd] 
     * @param {DonationOrderBy} [orderByColumn] 
     * @param {OrderByDirection} [orderByDirection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchDonations(page: number, pageSize: number, donatedById?: number | null, createdById?: number | null, minAmount?: number | null, maxAmount?: number | null, donatedAtStart?: string | null, donatedAtEnd?: string | null, orderByColumn?: DonationOrderBy, orderByDirection?: OrderByDirection, options?: RawAxiosRequestConfig) {
        return DonationApiFp(this.configuration).searchDonations(page, pageSize, donatedById, createdById, minAmount, maxAmount, donatedAtStart, donatedAtEnd, orderByColumn, orderByDirection, options).then((request) => request(this.axios, this.basePath));
    }
}


export const donationApi = new DonationApi(undefined, undefined, globalAxios);



export const createDonation = async (userCreatedDonation: UserCreatedDonation, options?: RawAxiosRequestConfig): Promise<Donation> => {
    const response = await donationApi.createDonation(userCreatedDonation, options);
    return response.data;
};


export const deleteDonation = async (deletedDonation: DeletedDonation, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await donationApi.deleteDonation(deletedDonation, options);
    return response.data;
};


export const editDonation = async (editedDonation: EditedDonation, options?: RawAxiosRequestConfig): Promise<Donation> => {
    const response = await donationApi.editDonation(editedDonation, options);
    return response.data;
};

export interface SearchDonationsRequest {
    /**  */
    'page': number;
    /**  */
    'page_size': number;
    /**  */
    'donated_by_id'?: number | null;
    /**  */
    'created_by_id'?: number | null;
    /**  */
    'min_amount'?: number | null;
    /**  */
    'max_amount'?: number | null;
    /**  */
    'donated_at_start'?: string | null;
    /**  */
    'donated_at_end'?: string | null;
    /**  */
    'order_by_column'?: DonationOrderBy | null;
    /**  */
    'order_by_direction'?: OrderByDirection | null;
}


export const searchDonations = async (requestParameters: SearchDonationsRequest, options?: RawAxiosRequestConfig): Promise<SearchDonationsResponse> => {
    const response = await donationApi.searchDonations(requestParameters['page']!, requestParameters['page_size']!, requestParameters['donated_by_id']!, requestParameters['created_by_id']!, requestParameters['min_amount']!, requestParameters['max_amount']!, requestParameters['donated_at_start']!, requestParameters['donated_at_end']!, requestParameters['order_by_column']!, requestParameters['order_by_direction']!, options);
    return response.data;
};


/**
 * EditionGroupApi - axios parameter creator
 */
export const EditionGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedEditionGroup} userCreatedEditionGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEditionGroup: async (userCreatedEditionGroup: UserCreatedEditionGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedEditionGroup' is not null or undefined
            assertParamExists('createEditionGroup', 'userCreatedEditionGroup', userCreatedEditionGroup)
            const localVarPath = `/api/edition-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedEditionGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EditionGroupApi - functional programming interface
 */
export const EditionGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EditionGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedEditionGroup} userCreatedEditionGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEditionGroup(userCreatedEditionGroup: UserCreatedEditionGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditionGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEditionGroup(userCreatedEditionGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EditionGroupApi.createEditionGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EditionGroupApi - factory interface
 */
export const EditionGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EditionGroupApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedEditionGroup} userCreatedEditionGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEditionGroup(userCreatedEditionGroup: UserCreatedEditionGroup, options?: RawAxiosRequestConfig): AxiosPromise<EditionGroup> {
            return localVarFp.createEditionGroup(userCreatedEditionGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EditionGroupApi - object-oriented interface
 */
export class EditionGroupApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedEditionGroup} userCreatedEditionGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createEditionGroup(userCreatedEditionGroup: UserCreatedEditionGroup, options?: RawAxiosRequestConfig) {
        return EditionGroupApiFp(this.configuration).createEditionGroup(userCreatedEditionGroup, options).then((request) => request(this.axios, this.basePath));
    }
}


export const editionGroupApi = new EditionGroupApi(undefined, undefined, globalAxios);



export const createEditionGroup = async (userCreatedEditionGroup: UserCreatedEditionGroup, options?: RawAxiosRequestConfig): Promise<EditionGroup> => {
    const response = await editionGroupApi.createEditionGroup(userCreatedEditionGroup, options);
    return response.data;
};


/**
 * ExternalSourceApi - axios parameter creator
 */
export const ExternalSourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComicVineData: async (url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('getComicVineData', 'url', url)
            const localVarPath = `/api/external-sources/comic-vine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} isbn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIsbnData: async (isbn: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'isbn' is not null or undefined
            assertParamExists('getIsbnData', 'isbn', isbn)
            const localVarPath = `/api/external-sources/isbn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isbn !== undefined) {
                localVarQueryParameter['isbn'] = isbn;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicbranzData: async (url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('getMusicbranzData', 'url', url)
            const localVarPath = `/api/external-sources/musicbrainz`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTMDBData: async (url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('getTMDBData', 'url', url)
            const localVarPath = `/api/external-sources/tmdb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExternalSourceApi - functional programming interface
 */
export const ExternalSourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExternalSourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComicVineData(url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalDBData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComicVineData(url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalSourceApi.getComicVineData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} isbn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIsbnData(isbn: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalDBData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIsbnData(isbn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalSourceApi.getIsbnData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicbranzData(url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalDBData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMusicbranzData(url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalSourceApi.getMusicbranzData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTMDBData(url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalDBData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTMDBData(url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalSourceApi.getTMDBData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExternalSourceApi - factory interface
 */
export const ExternalSourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExternalSourceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComicVineData(url: string, options?: RawAxiosRequestConfig): AxiosPromise<ExternalDBData> {
            return localVarFp.getComicVineData(url, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} isbn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIsbnData(isbn: string, options?: RawAxiosRequestConfig): AxiosPromise<ExternalDBData> {
            return localVarFp.getIsbnData(isbn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicbranzData(url: string, options?: RawAxiosRequestConfig): AxiosPromise<ExternalDBData> {
            return localVarFp.getMusicbranzData(url, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTMDBData(url: string, options?: RawAxiosRequestConfig): AxiosPromise<ExternalDBData> {
            return localVarFp.getTMDBData(url, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExternalSourceApi - object-oriented interface
 */
export class ExternalSourceApi extends BaseAPI {
    /**
     * 
     * @param {string} url 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getComicVineData(url: string, options?: RawAxiosRequestConfig) {
        return ExternalSourceApiFp(this.configuration).getComicVineData(url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} isbn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getIsbnData(isbn: string, options?: RawAxiosRequestConfig) {
        return ExternalSourceApiFp(this.configuration).getIsbnData(isbn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} url 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMusicbranzData(url: string, options?: RawAxiosRequestConfig) {
        return ExternalSourceApiFp(this.configuration).getMusicbranzData(url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} url 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTMDBData(url: string, options?: RawAxiosRequestConfig) {
        return ExternalSourceApiFp(this.configuration).getTMDBData(url, options).then((request) => request(this.axios, this.basePath));
    }
}


export const externalSourceApi = new ExternalSourceApi(undefined, undefined, globalAxios);



export const getComicVineData = async (url: string, options?: RawAxiosRequestConfig): Promise<ExternalDBData> => {
    const response = await externalSourceApi.getComicVineData(url, options);
    return response.data;
};


export const getIsbnData = async (isbn: string, options?: RawAxiosRequestConfig): Promise<ExternalDBData> => {
    const response = await externalSourceApi.getIsbnData(isbn, options);
    return response.data;
};


export const getMusicbranzData = async (url: string, options?: RawAxiosRequestConfig): Promise<ExternalDBData> => {
    const response = await externalSourceApi.getMusicbranzData(url, options);
    return response.data;
};


export const getTMDBData = async (url: string, options?: RawAxiosRequestConfig): Promise<ExternalDBData> => {
    const response = await externalSourceApi.getTMDBData(url, options);
    return response.data;
};


/**
 * ForumApi - axios parameter creator
 */
export const ForumApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedForumCategory} userCreatedForumCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForumCategory: async (userCreatedForumCategory: UserCreatedForumCategory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedForumCategory' is not null or undefined
            assertParamExists('createForumCategory', 'userCreatedForumCategory', userCreatedForumCategory)
            const localVarPath = `/api/forum/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedForumCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreatedForumPost} userCreatedForumPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForumPost: async (userCreatedForumPost: UserCreatedForumPost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedForumPost' is not null or undefined
            assertParamExists('createForumPost', 'userCreatedForumPost', userCreatedForumPost)
            const localVarPath = `/api/forum/post`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedForumPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreatedForumSubCategory} userCreatedForumSubCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForumSubCategory: async (userCreatedForumSubCategory: UserCreatedForumSubCategory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedForumSubCategory' is not null or undefined
            assertParamExists('createForumSubCategory', 'userCreatedForumSubCategory', userCreatedForumSubCategory)
            const localVarPath = `/api/forum/sub-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedForumSubCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreatedForumThread} userCreatedForumThread 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForumThread: async (userCreatedForumThread: UserCreatedForumThread, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedForumThread' is not null or undefined
            assertParamExists('createForumThread', 'userCreatedForumThread', userCreatedForumThread)
            const localVarPath = `/api/forum/thread`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedForumThread, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditedForumCategory} editedForumCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editForumCategory: async (editedForumCategory: EditedForumCategory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editedForumCategory' is not null or undefined
            assertParamExists('editForumCategory', 'editedForumCategory', editedForumCategory)
            const localVarPath = `/api/forum/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedForumCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditedForumPost} editedForumPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editForumPost: async (editedForumPost: EditedForumPost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editedForumPost' is not null or undefined
            assertParamExists('editForumPost', 'editedForumPost', editedForumPost)
            const localVarPath = `/api/forum/post`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedForumPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditedForumSubCategory} editedForumSubCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editForumSubCategory: async (editedForumSubCategory: EditedForumSubCategory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editedForumSubCategory' is not null or undefined
            assertParamExists('editForumSubCategory', 'editedForumSubCategory', editedForumSubCategory)
            const localVarPath = `/api/forum/sub-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedForumSubCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditedForumThread} editedForumThread 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editForumThread: async (editedForumThread: EditedForumThread, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editedForumThread' is not null or undefined
            assertParamExists('editForumThread', 'editedForumThread', editedForumThread)
            const localVarPath = `/api/forum/thread`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedForumThread, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForum: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/forum`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForumSubCategoryThreads: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getForumSubCategoryThreads', 'id', id)
            const localVarPath = `/api/forum/sub-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForumThread: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getForumThread', 'id', id)
            const localVarPath = `/api/forum/thread`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} threadId 
         * @param {number} pageSize 
         * @param {number | null} [page] 
         * @param {number | null} [postId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForumThreadsPosts: async (threadId: number, pageSize: number, page?: number | null, postId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('getForumThreadsPosts', 'threadId', threadId)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getForumThreadsPosts', 'pageSize', pageSize)
            const localVarPath = `/api/forum/thread/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (threadId !== undefined) {
                localVarQueryParameter['thread_id'] = threadId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (postId !== undefined) {
                localVarQueryParameter['post_id'] = postId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ForumApi - functional programming interface
 */
export const ForumApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ForumApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedForumCategory} userCreatedForumCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createForumCategory(userCreatedForumCategory: UserCreatedForumCategory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForumCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createForumCategory(userCreatedForumCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForumApi.createForumCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreatedForumPost} userCreatedForumPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createForumPost(userCreatedForumPost: UserCreatedForumPost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForumPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createForumPost(userCreatedForumPost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForumApi.createForumPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreatedForumSubCategory} userCreatedForumSubCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createForumSubCategory(userCreatedForumSubCategory: UserCreatedForumSubCategory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForumSubCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createForumSubCategory(userCreatedForumSubCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForumApi.createForumSubCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreatedForumThread} userCreatedForumThread 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createForumThread(userCreatedForumThread: UserCreatedForumThread, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForumThread>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createForumThread(userCreatedForumThread, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForumApi.createForumThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditedForumCategory} editedForumCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editForumCategory(editedForumCategory: EditedForumCategory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForumCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editForumCategory(editedForumCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForumApi.editForumCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditedForumPost} editedForumPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editForumPost(editedForumPost: EditedForumPost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForumPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editForumPost(editedForumPost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForumApi.editForumPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditedForumSubCategory} editedForumSubCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editForumSubCategory(editedForumSubCategory: EditedForumSubCategory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForumSubCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editForumSubCategory(editedForumSubCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForumApi.editForumSubCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditedForumThread} editedForumThread 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editForumThread(editedForumThread: EditedForumThread, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForumThreadEnriched>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editForumThread(editedForumThread, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForumApi.editForumThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForum(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForumOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForum(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForumApi.getForum']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForumSubCategoryThreads(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForumSubCategoryHierarchy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForumSubCategoryThreads(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForumApi.getForumSubCategoryThreads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForumThread(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForumThreadEnriched>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForumThread(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForumApi.getForumThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} threadId 
         * @param {number} pageSize 
         * @param {number | null} [page] 
         * @param {number | null} [postId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForumThreadsPosts(threadId: number, pageSize: number, page?: number | null, postId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResultsForumPostHierarchy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForumThreadsPosts(threadId, pageSize, page, postId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForumApi.getForumThreadsPosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ForumApi - factory interface
 */
export const ForumApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ForumApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedForumCategory} userCreatedForumCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForumCategory(userCreatedForumCategory: UserCreatedForumCategory, options?: RawAxiosRequestConfig): AxiosPromise<ForumCategory> {
            return localVarFp.createForumCategory(userCreatedForumCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreatedForumPost} userCreatedForumPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForumPost(userCreatedForumPost: UserCreatedForumPost, options?: RawAxiosRequestConfig): AxiosPromise<ForumPost> {
            return localVarFp.createForumPost(userCreatedForumPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreatedForumSubCategory} userCreatedForumSubCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForumSubCategory(userCreatedForumSubCategory: UserCreatedForumSubCategory, options?: RawAxiosRequestConfig): AxiosPromise<ForumSubCategory> {
            return localVarFp.createForumSubCategory(userCreatedForumSubCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreatedForumThread} userCreatedForumThread 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForumThread(userCreatedForumThread: UserCreatedForumThread, options?: RawAxiosRequestConfig): AxiosPromise<ForumThread> {
            return localVarFp.createForumThread(userCreatedForumThread, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditedForumCategory} editedForumCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editForumCategory(editedForumCategory: EditedForumCategory, options?: RawAxiosRequestConfig): AxiosPromise<ForumCategory> {
            return localVarFp.editForumCategory(editedForumCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditedForumPost} editedForumPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editForumPost(editedForumPost: EditedForumPost, options?: RawAxiosRequestConfig): AxiosPromise<ForumPost> {
            return localVarFp.editForumPost(editedForumPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditedForumSubCategory} editedForumSubCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editForumSubCategory(editedForumSubCategory: EditedForumSubCategory, options?: RawAxiosRequestConfig): AxiosPromise<ForumSubCategory> {
            return localVarFp.editForumSubCategory(editedForumSubCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditedForumThread} editedForumThread 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editForumThread(editedForumThread: EditedForumThread, options?: RawAxiosRequestConfig): AxiosPromise<ForumThreadEnriched> {
            return localVarFp.editForumThread(editedForumThread, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForum(options?: RawAxiosRequestConfig): AxiosPromise<ForumOverview> {
            return localVarFp.getForum(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForumSubCategoryThreads(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ForumSubCategoryHierarchy> {
            return localVarFp.getForumSubCategoryThreads(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForumThread(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ForumThreadEnriched> {
            return localVarFp.getForumThread(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} threadId 
         * @param {number} pageSize 
         * @param {number | null} [page] 
         * @param {number | null} [postId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForumThreadsPosts(threadId: number, pageSize: number, page?: number | null, postId?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResultsForumPostHierarchy> {
            return localVarFp.getForumThreadsPosts(threadId, pageSize, page, postId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ForumApi - object-oriented interface
 */
export class ForumApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedForumCategory} userCreatedForumCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createForumCategory(userCreatedForumCategory: UserCreatedForumCategory, options?: RawAxiosRequestConfig) {
        return ForumApiFp(this.configuration).createForumCategory(userCreatedForumCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreatedForumPost} userCreatedForumPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createForumPost(userCreatedForumPost: UserCreatedForumPost, options?: RawAxiosRequestConfig) {
        return ForumApiFp(this.configuration).createForumPost(userCreatedForumPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreatedForumSubCategory} userCreatedForumSubCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createForumSubCategory(userCreatedForumSubCategory: UserCreatedForumSubCategory, options?: RawAxiosRequestConfig) {
        return ForumApiFp(this.configuration).createForumSubCategory(userCreatedForumSubCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreatedForumThread} userCreatedForumThread 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createForumThread(userCreatedForumThread: UserCreatedForumThread, options?: RawAxiosRequestConfig) {
        return ForumApiFp(this.configuration).createForumThread(userCreatedForumThread, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditedForumCategory} editedForumCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editForumCategory(editedForumCategory: EditedForumCategory, options?: RawAxiosRequestConfig) {
        return ForumApiFp(this.configuration).editForumCategory(editedForumCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditedForumPost} editedForumPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editForumPost(editedForumPost: EditedForumPost, options?: RawAxiosRequestConfig) {
        return ForumApiFp(this.configuration).editForumPost(editedForumPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditedForumSubCategory} editedForumSubCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editForumSubCategory(editedForumSubCategory: EditedForumSubCategory, options?: RawAxiosRequestConfig) {
        return ForumApiFp(this.configuration).editForumSubCategory(editedForumSubCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditedForumThread} editedForumThread 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editForumThread(editedForumThread: EditedForumThread, options?: RawAxiosRequestConfig) {
        return ForumApiFp(this.configuration).editForumThread(editedForumThread, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getForum(options?: RawAxiosRequestConfig) {
        return ForumApiFp(this.configuration).getForum(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getForumSubCategoryThreads(id: number, options?: RawAxiosRequestConfig) {
        return ForumApiFp(this.configuration).getForumSubCategoryThreads(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getForumThread(id: number, options?: RawAxiosRequestConfig) {
        return ForumApiFp(this.configuration).getForumThread(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} threadId 
     * @param {number} pageSize 
     * @param {number | null} [page] 
     * @param {number | null} [postId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getForumThreadsPosts(threadId: number, pageSize: number, page?: number | null, postId?: number | null, options?: RawAxiosRequestConfig) {
        return ForumApiFp(this.configuration).getForumThreadsPosts(threadId, pageSize, page, postId, options).then((request) => request(this.axios, this.basePath));
    }
}


export const forumApi = new ForumApi(undefined, undefined, globalAxios);



export const createForumCategory = async (userCreatedForumCategory: UserCreatedForumCategory, options?: RawAxiosRequestConfig): Promise<ForumCategory> => {
    const response = await forumApi.createForumCategory(userCreatedForumCategory, options);
    return response.data;
};


export const createForumPost = async (userCreatedForumPost: UserCreatedForumPost, options?: RawAxiosRequestConfig): Promise<ForumPost> => {
    const response = await forumApi.createForumPost(userCreatedForumPost, options);
    return response.data;
};


export const createForumSubCategory = async (userCreatedForumSubCategory: UserCreatedForumSubCategory, options?: RawAxiosRequestConfig): Promise<ForumSubCategory> => {
    const response = await forumApi.createForumSubCategory(userCreatedForumSubCategory, options);
    return response.data;
};


export const createForumThread = async (userCreatedForumThread: UserCreatedForumThread, options?: RawAxiosRequestConfig): Promise<ForumThread> => {
    const response = await forumApi.createForumThread(userCreatedForumThread, options);
    return response.data;
};


export const editForumCategory = async (editedForumCategory: EditedForumCategory, options?: RawAxiosRequestConfig): Promise<ForumCategory> => {
    const response = await forumApi.editForumCategory(editedForumCategory, options);
    return response.data;
};


export const editForumPost = async (editedForumPost: EditedForumPost, options?: RawAxiosRequestConfig): Promise<ForumPost> => {
    const response = await forumApi.editForumPost(editedForumPost, options);
    return response.data;
};


export const editForumSubCategory = async (editedForumSubCategory: EditedForumSubCategory, options?: RawAxiosRequestConfig): Promise<ForumSubCategory> => {
    const response = await forumApi.editForumSubCategory(editedForumSubCategory, options);
    return response.data;
};


export const editForumThread = async (editedForumThread: EditedForumThread, options?: RawAxiosRequestConfig): Promise<ForumThreadEnriched> => {
    const response = await forumApi.editForumThread(editedForumThread, options);
    return response.data;
};


export const getForum = async (options?: RawAxiosRequestConfig): Promise<ForumOverview> => {
    const response = await forumApi.getForum(options);
    return response.data;
};


export const getForumSubCategoryThreads = async (id: number, options?: RawAxiosRequestConfig): Promise<ForumSubCategoryHierarchy> => {
    const response = await forumApi.getForumSubCategoryThreads(id, options);
    return response.data;
};


export const getForumThread = async (id: number, options?: RawAxiosRequestConfig): Promise<ForumThreadEnriched> => {
    const response = await forumApi.getForumThread(id, options);
    return response.data;
};

export interface GetForumThreadsPostsRequest {
    /**  */
    'thread_id': number;
    /**  */
    'page_size': number;
    /**  */
    'page'?: number | null;
    /**  */
    'post_id'?: number | null;
}


export const getForumThreadsPosts = async (requestParameters: GetForumThreadsPostsRequest, options?: RawAxiosRequestConfig): Promise<PaginatedResultsForumPostHierarchy> => {
    const response = await forumApi.getForumThreadsPosts(requestParameters['thread_id']!, requestParameters['page_size']!, requestParameters['page']!, requestParameters['post_id']!, options);
    return response.data;
};


/**
 * GiftApi - axios parameter creator
 */
export const GiftApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedGift} userCreatedGift 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGift: async (userCreatedGift: UserCreatedGift, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedGift' is not null or undefined
            assertParamExists('createGift', 'userCreatedGift', userCreatedGift)
            const localVarPath = `/api/gifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedGift, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiftApi - functional programming interface
 */
export const GiftApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GiftApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedGift} userCreatedGift 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGift(userCreatedGift: UserCreatedGift, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gift>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGift(userCreatedGift, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftApi.createGift']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GiftApi - factory interface
 */
export const GiftApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GiftApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedGift} userCreatedGift 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGift(userCreatedGift: UserCreatedGift, options?: RawAxiosRequestConfig): AxiosPromise<Gift> {
            return localVarFp.createGift(userCreatedGift, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GiftApi - object-oriented interface
 */
export class GiftApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedGift} userCreatedGift 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createGift(userCreatedGift: UserCreatedGift, options?: RawAxiosRequestConfig) {
        return GiftApiFp(this.configuration).createGift(userCreatedGift, options).then((request) => request(this.axios, this.basePath));
    }
}


export const giftApi = new GiftApi(undefined, undefined, globalAxios);



export const createGift = async (userCreatedGift: UserCreatedGift, options?: RawAxiosRequestConfig): Promise<Gift> => {
    const response = await giftApi.createGift(userCreatedGift, options);
    return response.data;
};


/**
 * HomeApi - axios parameter creator
 */
export const HomeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHomeData: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/home`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HomeApi - functional programming interface
 */
export const HomeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HomeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHomeData(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HomePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHomeData(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HomeApi.getHomeData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HomeApi - factory interface
 */
export const HomeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HomeApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHomeData(options?: RawAxiosRequestConfig): AxiosPromise<HomePage> {
            return localVarFp.getHomeData(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HomeApi - object-oriented interface
 */
export class HomeApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getHomeData(options?: RawAxiosRequestConfig) {
        return HomeApiFp(this.configuration).getHomeData(options).then((request) => request(this.axios, this.basePath));
    }
}


export const homeApi = new HomeApi(undefined, undefined, globalAxios);



export const getHomeData = async (options?: RawAxiosRequestConfig): Promise<HomePage> => {
    const response = await homeApi.getHomeData(options);
    return response.data;
};


/**
 * InvitationApi - axios parameter creator
 */
export const InvitationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SentInvitation} sentInvitation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvitation: async (sentInvitation: SentInvitation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sentInvitation' is not null or undefined
            assertParamExists('createInvitation', 'sentInvitation', sentInvitation)
            const localVarPath = `/api/invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sentInvitation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitationApi - functional programming interface
 */
export const InvitationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SentInvitation} sentInvitation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvitation(sentInvitation: SentInvitation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvitation(sentInvitation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitationApi.createInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvitationApi - factory interface
 */
export const InvitationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitationApiFp(configuration)
    return {
        /**
         * 
         * @param {SentInvitation} sentInvitation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvitation(sentInvitation: SentInvitation, options?: RawAxiosRequestConfig): AxiosPromise<Invitation> {
            return localVarFp.createInvitation(sentInvitation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitationApi - object-oriented interface
 */
export class InvitationApi extends BaseAPI {
    /**
     * 
     * @param {SentInvitation} sentInvitation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createInvitation(sentInvitation: SentInvitation, options?: RawAxiosRequestConfig) {
        return InvitationApiFp(this.configuration).createInvitation(sentInvitation, options).then((request) => request(this.axios, this.basePath));
    }
}


export const invitationApi = new InvitationApi(undefined, undefined, globalAxios);



export const createInvitation = async (sentInvitation: SentInvitation, options?: RawAxiosRequestConfig): Promise<Invitation> => {
    const response = await invitationApi.createInvitation(sentInvitation, options);
    return response.data;
};


/**
 * MasterGroupApi - axios parameter creator
 */
export const MasterGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedMasterGroup} userCreatedMasterGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterGroup: async (userCreatedMasterGroup: UserCreatedMasterGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedMasterGroup' is not null or undefined
            assertParamExists('createMasterGroup', 'userCreatedMasterGroup', userCreatedMasterGroup)
            const localVarPath = `/api/master-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedMasterGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MasterGroupApi - functional programming interface
 */
export const MasterGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MasterGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedMasterGroup} userCreatedMasterGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMasterGroup(userCreatedMasterGroup: UserCreatedMasterGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMasterGroup(userCreatedMasterGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MasterGroupApi.createMasterGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MasterGroupApi - factory interface
 */
export const MasterGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MasterGroupApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedMasterGroup} userCreatedMasterGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterGroup(userCreatedMasterGroup: UserCreatedMasterGroup, options?: RawAxiosRequestConfig): AxiosPromise<MasterGroup> {
            return localVarFp.createMasterGroup(userCreatedMasterGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MasterGroupApi - object-oriented interface
 */
export class MasterGroupApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedMasterGroup} userCreatedMasterGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createMasterGroup(userCreatedMasterGroup: UserCreatedMasterGroup, options?: RawAxiosRequestConfig) {
        return MasterGroupApiFp(this.configuration).createMasterGroup(userCreatedMasterGroup, options).then((request) => request(this.axios, this.basePath));
    }
}


export const masterGroupApi = new MasterGroupApi(undefined, undefined, globalAxios);



export const createMasterGroup = async (userCreatedMasterGroup: UserCreatedMasterGroup, options?: RawAxiosRequestConfig): Promise<MasterGroup> => {
    const response = await masterGroupApi.createMasterGroup(userCreatedMasterGroup, options);
    return response.data;
};


/**
 * NotificationApi - axios parameter creator
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {boolean} includeRead 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsForForumThreadPosts: async (includeRead: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'includeRead' is not null or undefined
            assertParamExists('getNotificationsForForumThreadPosts', 'includeRead', includeRead)
            const localVarPath = `/api/notifications/forum-thread-posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeRead !== undefined) {
                localVarQueryParameter['include_read'] = includeRead;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {boolean} includeRead 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationsForForumThreadPosts(includeRead: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationForumThreadPost>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationsForForumThreadPosts(includeRead, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.getNotificationsForForumThreadPosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationApi - factory interface
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * 
         * @param {boolean} includeRead 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsForForumThreadPosts(includeRead: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<NotificationForumThreadPost>> {
            return localVarFp.getNotificationsForForumThreadPosts(includeRead, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 */
export class NotificationApi extends BaseAPI {
    /**
     * 
     * @param {boolean} includeRead 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNotificationsForForumThreadPosts(includeRead: boolean, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).getNotificationsForForumThreadPosts(includeRead, options).then((request) => request(this.axios, this.basePath));
    }
}


export const notificationApi = new NotificationApi(undefined, undefined, globalAxios);



export const getNotificationsForForumThreadPosts = async (includeRead: boolean, options?: RawAxiosRequestConfig): Promise<Array<NotificationForumThreadPost>> => {
    const response = await notificationApi.getNotificationsForForumThreadPosts(includeRead, options);
    return response.data;
};


/**
 * SearchApi - axios parameter creator
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Case insensitive
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string | null} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtists: async (page: number, pageSize: number, name?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('searchArtists', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('searchArtists', 'pageSize', pageSize)
            const localVarPath = `/api/search/artists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Case insensitive
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtistsLite: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('searchArtistsLite', 'name', name)
            const localVarPath = `/api/search/artists/lite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Case insensitive
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string | null} [name] 
         * @param {Array<string> | null} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCollages: async (page: number, pageSize: number, name?: string | null, tags?: Array<string> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('searchCollages', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('searchCollages', 'pageSize', pageSize)
            const localVarPath = `/api/search/collages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Case insensitive
         * @param {string} name 
         * @param {number} resultsAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCollagesLite: async (name: string, resultsAmount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('searchCollagesLite', 'name', name)
            // verify required parameter 'resultsAmount' is not null or undefined
            assertParamExists('searchCollagesLite', 'resultsAmount', resultsAmount)
            const localVarPath = `/api/search/collages/lite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (resultsAmount !== undefined) {
                localVarQueryParameter['results_amount'] = resultsAmount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Case insensitive
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string | null} [threadName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForum: async (page: number, pageSize: number, threadName?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('searchForum', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('searchForum', 'pageSize', pageSize)
            const localVarPath = `/api/search/forum`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (threadName !== undefined) {
                localVarQueryParameter['thread_name'] = threadName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Case insensitive
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string | null} [name] 
         * @param {Array<string> | null} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSeries: async (page: number, pageSize: number, name?: string | null, tags?: Array<string> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('searchSeries', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('searchSeries', 'pageSize', pageSize)
            const localVarPath = `/api/search/series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Case insensitive
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSeriesLite: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('searchSeriesLite', 'name', name)
            const localVarPath = `/api/search/series/lite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ContentType | null} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTitleGroupInfo: async (name: string, contentType?: ContentType | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('searchTitleGroupInfo', 'name', name)
            const localVarPath = `/api/search/title-groups/lite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['content_type'] = contentType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {TitleGroupTagSearchOrderByColumn} orderByColumn 
         * @param {OrderByDirection} orderByDirection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTitleGroupTags: async (name: string, page: number, pageSize: number, orderByColumn: TitleGroupTagSearchOrderByColumn, orderByDirection: OrderByDirection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('searchTitleGroupTags', 'name', name)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('searchTitleGroupTags', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('searchTitleGroupTags', 'pageSize', pageSize)
            // verify required parameter 'orderByColumn' is not null or undefined
            assertParamExists('searchTitleGroupTags', 'orderByColumn', orderByColumn)
            // verify required parameter 'orderByDirection' is not null or undefined
            assertParamExists('searchTitleGroupTags', 'orderByDirection', orderByDirection)
            const localVarPath = `/api/search/title-group-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (orderByColumn !== undefined) {
                localVarQueryParameter['order_by_column'] = orderByColumn;
            }

            if (orderByDirection !== undefined) {
                localVarQueryParameter['order_by_direction'] = orderByDirection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTitleGroupTagsLite: async (name: string, page: number, pageSize: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('searchTitleGroupTagsLite', 'name', name)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('searchTitleGroupTagsLite', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('searchTitleGroupTagsLite', 'pageSize', pageSize)
            const localVarPath = `/api/search/title-group-tags/lite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [titleGroupName] Name of the title group to search for
         * @param {Array<string>} [tags] Tags to filter title groups by
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Results per page (default 50)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTorrentRequests: async (titleGroupName?: string, tags?: Array<string>, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/search/torrent-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (titleGroupName !== undefined) {
                localVarQueryParameter['title_group_name'] = titleGroupName;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} titleGroupIncludeEmptyGroups 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {TorrentSearchOrderByColumn} orderByColumn 
         * @param {OrderByDirection} orderByDirection 
         * @param {string | null} [titleGroupName] 
         * @param {boolean | null} [torrentReported] 
         * @param {boolean | null} [torrentStaffChecked] 
         * @param {number | null} [torrentCreatedById] 
         * @param {number | null} [torrentSnatchedById] 
         * @param {number | null} [artistId] 
         * @param {number | null} [collageId] 
         * @param {number | null} [seriesId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTorrents: async (titleGroupIncludeEmptyGroups: boolean, page: number, pageSize: number, orderByColumn: TorrentSearchOrderByColumn, orderByDirection: OrderByDirection, titleGroupName?: string | null, torrentReported?: boolean | null, torrentStaffChecked?: boolean | null, torrentCreatedById?: number | null, torrentSnatchedById?: number | null, artistId?: number | null, collageId?: number | null, seriesId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'titleGroupIncludeEmptyGroups' is not null or undefined
            assertParamExists('searchTorrents', 'titleGroupIncludeEmptyGroups', titleGroupIncludeEmptyGroups)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('searchTorrents', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('searchTorrents', 'pageSize', pageSize)
            // verify required parameter 'orderByColumn' is not null or undefined
            assertParamExists('searchTorrents', 'orderByColumn', orderByColumn)
            // verify required parameter 'orderByDirection' is not null or undefined
            assertParamExists('searchTorrents', 'orderByDirection', orderByDirection)
            const localVarPath = `/api/search/torrents/lite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (titleGroupName !== undefined) {
                localVarQueryParameter['title_group_name'] = titleGroupName;
            }

            if (titleGroupIncludeEmptyGroups !== undefined) {
                localVarQueryParameter['title_group_include_empty_groups'] = titleGroupIncludeEmptyGroups;
            }

            if (torrentReported !== undefined) {
                localVarQueryParameter['torrent_reported'] = torrentReported;
            }

            if (torrentStaffChecked !== undefined) {
                localVarQueryParameter['torrent_staff_checked'] = torrentStaffChecked;
            }

            if (torrentCreatedById !== undefined) {
                localVarQueryParameter['torrent_created_by_id'] = torrentCreatedById;
            }

            if (torrentSnatchedById !== undefined) {
                localVarQueryParameter['torrent_snatched_by_id'] = torrentSnatchedById;
            }

            if (artistId !== undefined) {
                localVarQueryParameter['artist_id'] = artistId;
            }

            if (collageId !== undefined) {
                localVarQueryParameter['collage_id'] = collageId;
            }

            if (seriesId !== undefined) {
                localVarQueryParameter['series_id'] = seriesId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (orderByColumn !== undefined) {
                localVarQueryParameter['order_by_column'] = orderByColumn;
            }

            if (orderByDirection !== undefined) {
                localVarQueryParameter['order_by_direction'] = orderByDirection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Case insensitive
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersLite: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('searchUsersLite', 'username', username)
            const localVarPath = `/api/search/users/lite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Case insensitive
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string | null} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchArtists(page: number, pageSize: number, name?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResultsArtistSearchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchArtists(page, pageSize, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchArtists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Case insensitive
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchArtistsLite(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtistLite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchArtistsLite(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchArtistsLite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Case insensitive
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string | null} [name] 
         * @param {Array<string> | null} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCollages(page: number, pageSize: number, name?: string | null, tags?: Array<string> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResultsCollageSearchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCollages(page, pageSize, name, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchCollages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Case insensitive
         * @param {string} name 
         * @param {number} resultsAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCollagesLite(name: string, resultsAmount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CollageLite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCollagesLite(name, resultsAmount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchCollagesLite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Case insensitive
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string | null} [threadName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchForum(page: number, pageSize: number, threadName?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResultsForumSearchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchForum(page, pageSize, threadName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchForum']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Case insensitive
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string | null} [name] 
         * @param {Array<string> | null} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSeries(page: number, pageSize: number, name?: string | null, tags?: Array<string> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSeries(page, pageSize, name, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchSeries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Case insensitive
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSeriesLite(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SeriesLite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSeriesLite(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchSeriesLite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {ContentType | null} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTitleGroupInfo(name: string, contentType?: ContentType | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TitleGroupLite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTitleGroupInfo(name, contentType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchTitleGroupInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {TitleGroupTagSearchOrderByColumn} orderByColumn 
         * @param {OrderByDirection} orderByDirection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTitleGroupTags(name: string, page: number, pageSize: number, orderByColumn: TitleGroupTagSearchOrderByColumn, orderByDirection: OrderByDirection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResultsTitleGroupTagEnriched>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTitleGroupTags(name, page, pageSize, orderByColumn, orderByDirection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchTitleGroupTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTitleGroupTagsLite(name: string, page: number, pageSize: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResultsTitleGroupTagLite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTitleGroupTagsLite(name, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchTitleGroupTagsLite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [titleGroupName] Name of the title group to search for
         * @param {Array<string>} [tags] Tags to filter title groups by
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Results per page (default 50)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTorrentRequests(titleGroupName?: string, tags?: Array<string>, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TorrentRequestWithTitleGroupLite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTorrentRequests(titleGroupName, tags, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchTorrentRequests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} titleGroupIncludeEmptyGroups 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {TorrentSearchOrderByColumn} orderByColumn 
         * @param {OrderByDirection} orderByDirection 
         * @param {string | null} [titleGroupName] 
         * @param {boolean | null} [torrentReported] 
         * @param {boolean | null} [torrentStaffChecked] 
         * @param {number | null} [torrentCreatedById] 
         * @param {number | null} [torrentSnatchedById] 
         * @param {number | null} [artistId] 
         * @param {number | null} [collageId] 
         * @param {number | null} [seriesId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTorrents(titleGroupIncludeEmptyGroups: boolean, page: number, pageSize: number, orderByColumn: TorrentSearchOrderByColumn, orderByDirection: OrderByDirection, titleGroupName?: string | null, torrentReported?: boolean | null, torrentStaffChecked?: boolean | null, torrentCreatedById?: number | null, torrentSnatchedById?: number | null, artistId?: number | null, collageId?: number | null, seriesId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResultsTitleGroupHierarchyLite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTorrents(titleGroupIncludeEmptyGroups, page, pageSize, orderByColumn, orderByDirection, titleGroupName, torrentReported, torrentStaffChecked, torrentCreatedById, torrentSnatchedById, artistId, collageId, seriesId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchTorrents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Case insensitive
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsersLite(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserLite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsersLite(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchUsersLite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Case insensitive
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string | null} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtists(page: number, pageSize: number, name?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResultsArtistSearchResult> {
            return localVarFp.searchArtists(page, pageSize, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Case insensitive
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtistsLite(name: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ArtistLite>> {
            return localVarFp.searchArtistsLite(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Case insensitive
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string | null} [name] 
         * @param {Array<string> | null} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCollages(page: number, pageSize: number, name?: string | null, tags?: Array<string> | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResultsCollageSearchResult> {
            return localVarFp.searchCollages(page, pageSize, name, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Case insensitive
         * @param {string} name 
         * @param {number} resultsAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCollagesLite(name: string, resultsAmount: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<CollageLite>> {
            return localVarFp.searchCollagesLite(name, resultsAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * Case insensitive
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string | null} [threadName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForum(page: number, pageSize: number, threadName?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResultsForumSearchResult> {
            return localVarFp.searchForum(page, pageSize, threadName, options).then((request) => request(axios, basePath));
        },
        /**
         * Case insensitive
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string | null} [name] 
         * @param {Array<string> | null} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSeries(page: number, pageSize: number, name?: string | null, tags?: Array<string> | null, options?: RawAxiosRequestConfig): AxiosPromise<SeriesSearchResponse> {
            return localVarFp.searchSeries(page, pageSize, name, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Case insensitive
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSeriesLite(name: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SeriesLite>> {
            return localVarFp.searchSeriesLite(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {ContentType | null} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTitleGroupInfo(name: string, contentType?: ContentType | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<TitleGroupLite>> {
            return localVarFp.searchTitleGroupInfo(name, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {TitleGroupTagSearchOrderByColumn} orderByColumn 
         * @param {OrderByDirection} orderByDirection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTitleGroupTags(name: string, page: number, pageSize: number, orderByColumn: TitleGroupTagSearchOrderByColumn, orderByDirection: OrderByDirection, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResultsTitleGroupTagEnriched> {
            return localVarFp.searchTitleGroupTags(name, page, pageSize, orderByColumn, orderByDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTitleGroupTagsLite(name: string, page: number, pageSize: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResultsTitleGroupTagLite> {
            return localVarFp.searchTitleGroupTagsLite(name, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [titleGroupName] Name of the title group to search for
         * @param {Array<string>} [tags] Tags to filter title groups by
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Results per page (default 50)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTorrentRequests(titleGroupName?: string, tags?: Array<string>, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TorrentRequestWithTitleGroupLite>> {
            return localVarFp.searchTorrentRequests(titleGroupName, tags, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} titleGroupIncludeEmptyGroups 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {TorrentSearchOrderByColumn} orderByColumn 
         * @param {OrderByDirection} orderByDirection 
         * @param {string | null} [titleGroupName] 
         * @param {boolean | null} [torrentReported] 
         * @param {boolean | null} [torrentStaffChecked] 
         * @param {number | null} [torrentCreatedById] 
         * @param {number | null} [torrentSnatchedById] 
         * @param {number | null} [artistId] 
         * @param {number | null} [collageId] 
         * @param {number | null} [seriesId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTorrents(titleGroupIncludeEmptyGroups: boolean, page: number, pageSize: number, orderByColumn: TorrentSearchOrderByColumn, orderByDirection: OrderByDirection, titleGroupName?: string | null, torrentReported?: boolean | null, torrentStaffChecked?: boolean | null, torrentCreatedById?: number | null, torrentSnatchedById?: number | null, artistId?: number | null, collageId?: number | null, seriesId?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResultsTitleGroupHierarchyLite> {
            return localVarFp.searchTorrents(titleGroupIncludeEmptyGroups, page, pageSize, orderByColumn, orderByDirection, titleGroupName, torrentReported, torrentStaffChecked, torrentCreatedById, torrentSnatchedById, artistId, collageId, seriesId, options).then((request) => request(axios, basePath));
        },
        /**
         * Case insensitive
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersLite(username: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserLite>> {
            return localVarFp.searchUsersLite(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 */
export class SearchApi extends BaseAPI {
    /**
     * Case insensitive
     * @param {number} page 
     * @param {number} pageSize 
     * @param {string | null} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchArtists(page: number, pageSize: number, name?: string | null, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchArtists(page, pageSize, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Case insensitive
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchArtistsLite(name: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchArtistsLite(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Case insensitive
     * @param {number} page 
     * @param {number} pageSize 
     * @param {string | null} [name] 
     * @param {Array<string> | null} [tags] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchCollages(page: number, pageSize: number, name?: string | null, tags?: Array<string> | null, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchCollages(page, pageSize, name, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Case insensitive
     * @param {string} name 
     * @param {number} resultsAmount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchCollagesLite(name: string, resultsAmount: number, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchCollagesLite(name, resultsAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Case insensitive
     * @param {number} page 
     * @param {number} pageSize 
     * @param {string | null} [threadName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchForum(page: number, pageSize: number, threadName?: string | null, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchForum(page, pageSize, threadName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Case insensitive
     * @param {number} page 
     * @param {number} pageSize 
     * @param {string | null} [name] 
     * @param {Array<string> | null} [tags] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchSeries(page: number, pageSize: number, name?: string | null, tags?: Array<string> | null, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchSeries(page, pageSize, name, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Case insensitive
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchSeriesLite(name: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchSeriesLite(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {ContentType | null} [contentType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchTitleGroupInfo(name: string, contentType?: ContentType | null, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchTitleGroupInfo(name, contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {number} page 
     * @param {number} pageSize 
     * @param {TitleGroupTagSearchOrderByColumn} orderByColumn 
     * @param {OrderByDirection} orderByDirection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchTitleGroupTags(name: string, page: number, pageSize: number, orderByColumn: TitleGroupTagSearchOrderByColumn, orderByDirection: OrderByDirection, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchTitleGroupTags(name, page, pageSize, orderByColumn, orderByDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {number} page 
     * @param {number} pageSize 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchTitleGroupTagsLite(name: string, page: number, pageSize: number, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchTitleGroupTagsLite(name, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [titleGroupName] Name of the title group to search for
     * @param {Array<string>} [tags] Tags to filter title groups by
     * @param {number} [page] Page number (default 1)
     * @param {number} [pageSize] Results per page (default 50)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchTorrentRequests(titleGroupName?: string, tags?: Array<string>, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchTorrentRequests(titleGroupName, tags, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} titleGroupIncludeEmptyGroups 
     * @param {number} page 
     * @param {number} pageSize 
     * @param {TorrentSearchOrderByColumn} orderByColumn 
     * @param {OrderByDirection} orderByDirection 
     * @param {string | null} [titleGroupName] 
     * @param {boolean | null} [torrentReported] 
     * @param {boolean | null} [torrentStaffChecked] 
     * @param {number | null} [torrentCreatedById] 
     * @param {number | null} [torrentSnatchedById] 
     * @param {number | null} [artistId] 
     * @param {number | null} [collageId] 
     * @param {number | null} [seriesId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchTorrents(titleGroupIncludeEmptyGroups: boolean, page: number, pageSize: number, orderByColumn: TorrentSearchOrderByColumn, orderByDirection: OrderByDirection, titleGroupName?: string | null, torrentReported?: boolean | null, torrentStaffChecked?: boolean | null, torrentCreatedById?: number | null, torrentSnatchedById?: number | null, artistId?: number | null, collageId?: number | null, seriesId?: number | null, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchTorrents(titleGroupIncludeEmptyGroups, page, pageSize, orderByColumn, orderByDirection, titleGroupName, torrentReported, torrentStaffChecked, torrentCreatedById, torrentSnatchedById, artistId, collageId, seriesId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Case insensitive
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchUsersLite(username: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchUsersLite(username, options).then((request) => request(this.axios, this.basePath));
    }
}


export const searchApi = new SearchApi(undefined, undefined, globalAxios);


export interface SearchArtistsRequest {
    /**  */
    'page': number;
    /**  */
    'page_size': number;
    /**  */
    'name'?: string | null;
}


export const searchArtists = async (requestParameters: SearchArtistsRequest, options?: RawAxiosRequestConfig): Promise<PaginatedResultsArtistSearchResult> => {
    const response = await searchApi.searchArtists(requestParameters['page']!, requestParameters['page_size']!, requestParameters['name']!, options);
    return response.data;
};


export const searchArtistsLite = async (name: string, options?: RawAxiosRequestConfig): Promise<Array<ArtistLite>> => {
    const response = await searchApi.searchArtistsLite(name, options);
    return response.data;
};

export interface SearchCollagesRequest {
    /**  */
    'page': number;
    /**  */
    'page_size': number;
    /**  */
    'name'?: string | null;
    /**  */
    'tags'?: Array<string> | null;
}


export const searchCollages = async (requestParameters: SearchCollagesRequest, options?: RawAxiosRequestConfig): Promise<PaginatedResultsCollageSearchResult> => {
    const response = await searchApi.searchCollages(requestParameters['page']!, requestParameters['page_size']!, requestParameters['name']!, requestParameters['tags']!, options);
    return response.data;
};

export interface SearchCollagesLiteRequest {
    /**  */
    'name': string;
    /**  */
    'results_amount': number;
}


export const searchCollagesLite = async (requestParameters: SearchCollagesLiteRequest, options?: RawAxiosRequestConfig): Promise<Array<CollageLite>> => {
    const response = await searchApi.searchCollagesLite(requestParameters['name']!, requestParameters['results_amount']!, options);
    return response.data;
};

export interface SearchForumRequest {
    /**  */
    'page': number;
    /**  */
    'page_size': number;
    /**  */
    'thread_name'?: string | null;
}


export const searchForum = async (requestParameters: SearchForumRequest, options?: RawAxiosRequestConfig): Promise<PaginatedResultsForumSearchResult> => {
    const response = await searchApi.searchForum(requestParameters['page']!, requestParameters['page_size']!, requestParameters['thread_name']!, options);
    return response.data;
};

export interface SearchSeriesRequest {
    /**  */
    'page': number;
    /**  */
    'page_size': number;
    /**  */
    'name'?: string | null;
    /**  */
    'tags'?: Array<string> | null;
}


export const searchSeries = async (requestParameters: SearchSeriesRequest, options?: RawAxiosRequestConfig): Promise<SeriesSearchResponse> => {
    const response = await searchApi.searchSeries(requestParameters['page']!, requestParameters['page_size']!, requestParameters['name']!, requestParameters['tags']!, options);
    return response.data;
};


export const searchSeriesLite = async (name: string, options?: RawAxiosRequestConfig): Promise<Array<SeriesLite>> => {
    const response = await searchApi.searchSeriesLite(name, options);
    return response.data;
};

export interface SearchTitleGroupInfoRequest {
    /**  */
    'name': string;
    /**  */
    'content_type'?: ContentType | null;
}


export const searchTitleGroupInfo = async (requestParameters: SearchTitleGroupInfoRequest, options?: RawAxiosRequestConfig): Promise<Array<TitleGroupLite>> => {
    const response = await searchApi.searchTitleGroupInfo(requestParameters['name']!, requestParameters['content_type']!, options);
    return response.data;
};

export interface SearchTitleGroupTagsRequest {
    /**  */
    'name': string;
    /**  */
    'page': number;
    /**  */
    'page_size': number;
    /**  */
    'order_by_column': TitleGroupTagSearchOrderByColumn;
    /**  */
    'order_by_direction': OrderByDirection;
}


export const searchTitleGroupTags = async (requestParameters: SearchTitleGroupTagsRequest, options?: RawAxiosRequestConfig): Promise<PaginatedResultsTitleGroupTagEnriched> => {
    const response = await searchApi.searchTitleGroupTags(requestParameters['name']!, requestParameters['page']!, requestParameters['page_size']!, requestParameters['order_by_column']!, requestParameters['order_by_direction']!, options);
    return response.data;
};

export interface SearchTitleGroupTagsLiteRequest {
    /**  */
    'name': string;
    /**  */
    'page': number;
    /**  */
    'page_size': number;
}


export const searchTitleGroupTagsLite = async (requestParameters: SearchTitleGroupTagsLiteRequest, options?: RawAxiosRequestConfig): Promise<PaginatedResultsTitleGroupTagLite> => {
    const response = await searchApi.searchTitleGroupTagsLite(requestParameters['name']!, requestParameters['page']!, requestParameters['page_size']!, options);
    return response.data;
};

export interface SearchTorrentRequestsRequest {
    /** Name of the title group to search for */
    'title_group_name'?: string | null;
    /** Tags to filter title groups by */
    'tags'?: Array<string> | null;
    /** Page number (default 1) */
    'page'?: number | null;
    /** Results per page (default 50) */
    'page_size'?: number | null;
}


export const searchTorrentRequests = async (requestParameters: SearchTorrentRequestsRequest, options?: RawAxiosRequestConfig): Promise<Array<TorrentRequestWithTitleGroupLite>> => {
    const response = await searchApi.searchTorrentRequests(requestParameters['title_group_name']!, requestParameters['tags']!, requestParameters['page']!, requestParameters['page_size']!, options);
    return response.data;
};

export interface SearchTorrentsRequest {
    /**  */
    'title_group_include_empty_groups': boolean;
    /**  */
    'page': number;
    /**  */
    'page_size': number;
    /**  */
    'order_by_column': TorrentSearchOrderByColumn;
    /**  */
    'order_by_direction': OrderByDirection;
    /**  */
    'title_group_name'?: string | null;
    /**  */
    'torrent_reported'?: boolean | null;
    /**  */
    'torrent_staff_checked'?: boolean | null;
    /**  */
    'torrent_created_by_id'?: number | null;
    /**  */
    'torrent_snatched_by_id'?: number | null;
    /**  */
    'artist_id'?: number | null;
    /**  */
    'collage_id'?: number | null;
    /**  */
    'series_id'?: number | null;
}


export const searchTorrents = async (requestParameters: SearchTorrentsRequest, options?: RawAxiosRequestConfig): Promise<PaginatedResultsTitleGroupHierarchyLite> => {
    const response = await searchApi.searchTorrents(requestParameters['title_group_include_empty_groups']!, requestParameters['page']!, requestParameters['page_size']!, requestParameters['order_by_column']!, requestParameters['order_by_direction']!, requestParameters['title_group_name']!, requestParameters['torrent_reported']!, requestParameters['torrent_staff_checked']!, requestParameters['torrent_created_by_id']!, requestParameters['torrent_snatched_by_id']!, requestParameters['artist_id']!, requestParameters['collage_id']!, requestParameters['series_id']!, options);
    return response.data;
};


export const searchUsersLite = async (username: string, options?: RawAxiosRequestConfig): Promise<Array<UserLite>> => {
    const response = await searchApi.searchUsersLite(username, options);
    return response.data;
};


/**
 * SeriesApi - axios parameter creator
 */
export const SeriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddTitleGroupToSeriesRequest} addTitleGroupToSeriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTitleGroupToSeries: async (addTitleGroupToSeriesRequest: AddTitleGroupToSeriesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addTitleGroupToSeriesRequest' is not null or undefined
            assertParamExists('addTitleGroupToSeries', 'addTitleGroupToSeriesRequest', addTitleGroupToSeriesRequest)
            const localVarPath = `/api/series/title-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTitleGroupToSeriesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreatedSeries} userCreatedSeries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeries: async (userCreatedSeries: UserCreatedSeries, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedSeries' is not null or undefined
            assertParamExists('createSeries', 'userCreatedSeries', userCreatedSeries)
            const localVarPath = `/api/series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedSeries, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditedSeries} editedSeries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editSeries: async (editedSeries: EditedSeries, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editedSeries' is not null or undefined
            assertParamExists('editSeries', 'editedSeries', editedSeries)
            const localVarPath = `/api/series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedSeries, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeries: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSeries', 'id', id)
            const localVarPath = `/api/series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SeriesApi - functional programming interface
 */
export const SeriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SeriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddTitleGroupToSeriesRequest} addTitleGroupToSeriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTitleGroupToSeries(addTitleGroupToSeriesRequest: AddTitleGroupToSeriesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TitleGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTitleGroupToSeries(addTitleGroupToSeriesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SeriesApi.addTitleGroupToSeries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreatedSeries} userCreatedSeries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSeries(userCreatedSeries: UserCreatedSeries, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Series>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSeries(userCreatedSeries, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SeriesApi.createSeries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditedSeries} editedSeries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editSeries(editedSeries: EditedSeries, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Series>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editSeries(editedSeries, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SeriesApi.editSeries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeries(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesAndTitleGroupHierarchyLite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSeries(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SeriesApi.getSeries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SeriesApi - factory interface
 */
export const SeriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SeriesApiFp(configuration)
    return {
        /**
         * 
         * @param {AddTitleGroupToSeriesRequest} addTitleGroupToSeriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTitleGroupToSeries(addTitleGroupToSeriesRequest: AddTitleGroupToSeriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TitleGroup> {
            return localVarFp.addTitleGroupToSeries(addTitleGroupToSeriesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreatedSeries} userCreatedSeries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeries(userCreatedSeries: UserCreatedSeries, options?: RawAxiosRequestConfig): AxiosPromise<Series> {
            return localVarFp.createSeries(userCreatedSeries, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditedSeries} editedSeries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editSeries(editedSeries: EditedSeries, options?: RawAxiosRequestConfig): AxiosPromise<Series> {
            return localVarFp.editSeries(editedSeries, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeries(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SeriesAndTitleGroupHierarchyLite> {
            return localVarFp.getSeries(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SeriesApi - object-oriented interface
 */
export class SeriesApi extends BaseAPI {
    /**
     * 
     * @param {AddTitleGroupToSeriesRequest} addTitleGroupToSeriesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addTitleGroupToSeries(addTitleGroupToSeriesRequest: AddTitleGroupToSeriesRequest, options?: RawAxiosRequestConfig) {
        return SeriesApiFp(this.configuration).addTitleGroupToSeries(addTitleGroupToSeriesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreatedSeries} userCreatedSeries 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createSeries(userCreatedSeries: UserCreatedSeries, options?: RawAxiosRequestConfig) {
        return SeriesApiFp(this.configuration).createSeries(userCreatedSeries, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditedSeries} editedSeries 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editSeries(editedSeries: EditedSeries, options?: RawAxiosRequestConfig) {
        return SeriesApiFp(this.configuration).editSeries(editedSeries, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSeries(id: number, options?: RawAxiosRequestConfig) {
        return SeriesApiFp(this.configuration).getSeries(id, options).then((request) => request(this.axios, this.basePath));
    }
}


export const seriesApi = new SeriesApi(undefined, undefined, globalAxios);



export const addTitleGroupToSeries = async (addTitleGroupToSeriesRequest: AddTitleGroupToSeriesRequest, options?: RawAxiosRequestConfig): Promise<TitleGroup> => {
    const response = await seriesApi.addTitleGroupToSeries(addTitleGroupToSeriesRequest, options);
    return response.data;
};


export const createSeries = async (userCreatedSeries: UserCreatedSeries, options?: RawAxiosRequestConfig): Promise<Series> => {
    const response = await seriesApi.createSeries(userCreatedSeries, options);
    return response.data;
};


export const editSeries = async (editedSeries: EditedSeries, options?: RawAxiosRequestConfig): Promise<Series> => {
    const response = await seriesApi.editSeries(editedSeries, options);
    return response.data;
};


export const getSeries = async (id: number, options?: RawAxiosRequestConfig): Promise<SeriesAndTitleGroupHierarchyLite> => {
    const response = await seriesApi.getSeries(id, options);
    return response.data;
};


/**
 * StaffPMApi - axios parameter creator
 */
export const StaffPMApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedStaffPm} userCreatedStaffPm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStaffPM: async (userCreatedStaffPm: UserCreatedStaffPm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedStaffPm' is not null or undefined
            assertParamExists('createStaffPM', 'userCreatedStaffPm', userCreatedStaffPm)
            const localVarPath = `/api/staff-pms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedStaffPm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreatedStaffPmMessage} userCreatedStaffPmMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStaffPMMessage: async (userCreatedStaffPmMessage: UserCreatedStaffPmMessage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedStaffPmMessage' is not null or undefined
            assertParamExists('createStaffPMMessage', 'userCreatedStaffPmMessage', userCreatedStaffPmMessage)
            const localVarPath = `/api/staff-pms/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedStaffPmMessage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Staff PM id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaffPM: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStaffPM', 'id', id)
            const localVarPath = `/api/staff-pms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStaffPMs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/staff-pms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Staff PM id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveStaffPM: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resolveStaffPM', 'id', id)
            const localVarPath = `/api/staff-pms/{id}/resolve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Staff PM id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unresolveStaffPM: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unresolveStaffPM', 'id', id)
            const localVarPath = `/api/staff-pms/{id}/unresolve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StaffPMApi - functional programming interface
 */
export const StaffPMApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StaffPMApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedStaffPm} userCreatedStaffPm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStaffPM(userCreatedStaffPm: UserCreatedStaffPm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffPm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStaffPM(userCreatedStaffPm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffPMApi.createStaffPM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreatedStaffPmMessage} userCreatedStaffPmMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStaffPMMessage(userCreatedStaffPmMessage: UserCreatedStaffPmMessage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffPmMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStaffPMMessage(userCreatedStaffPmMessage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffPMApi.createStaffPMMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id Staff PM id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStaffPM(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffPmHierarchy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStaffPM(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffPMApi.getStaffPM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStaffPMs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StaffPmOverview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStaffPMs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffPMApi.listStaffPMs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id Staff PM id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveStaffPM(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffPm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveStaffPM(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffPMApi.resolveStaffPM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id Staff PM id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unresolveStaffPM(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffPm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unresolveStaffPM(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffPMApi.unresolveStaffPM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StaffPMApi - factory interface
 */
export const StaffPMApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StaffPMApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedStaffPm} userCreatedStaffPm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStaffPM(userCreatedStaffPm: UserCreatedStaffPm, options?: RawAxiosRequestConfig): AxiosPromise<StaffPm> {
            return localVarFp.createStaffPM(userCreatedStaffPm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreatedStaffPmMessage} userCreatedStaffPmMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStaffPMMessage(userCreatedStaffPmMessage: UserCreatedStaffPmMessage, options?: RawAxiosRequestConfig): AxiosPromise<StaffPmMessage> {
            return localVarFp.createStaffPMMessage(userCreatedStaffPmMessage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Staff PM id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaffPM(id: number, options?: RawAxiosRequestConfig): AxiosPromise<StaffPmHierarchy> {
            return localVarFp.getStaffPM(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStaffPMs(options?: RawAxiosRequestConfig): AxiosPromise<Array<StaffPmOverview>> {
            return localVarFp.listStaffPMs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Staff PM id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveStaffPM(id: number, options?: RawAxiosRequestConfig): AxiosPromise<StaffPm> {
            return localVarFp.resolveStaffPM(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Staff PM id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unresolveStaffPM(id: number, options?: RawAxiosRequestConfig): AxiosPromise<StaffPm> {
            return localVarFp.unresolveStaffPM(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StaffPMApi - object-oriented interface
 */
export class StaffPMApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedStaffPm} userCreatedStaffPm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createStaffPM(userCreatedStaffPm: UserCreatedStaffPm, options?: RawAxiosRequestConfig) {
        return StaffPMApiFp(this.configuration).createStaffPM(userCreatedStaffPm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreatedStaffPmMessage} userCreatedStaffPmMessage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createStaffPMMessage(userCreatedStaffPmMessage: UserCreatedStaffPmMessage, options?: RawAxiosRequestConfig) {
        return StaffPMApiFp(this.configuration).createStaffPMMessage(userCreatedStaffPmMessage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Staff PM id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStaffPM(id: number, options?: RawAxiosRequestConfig) {
        return StaffPMApiFp(this.configuration).getStaffPM(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listStaffPMs(options?: RawAxiosRequestConfig) {
        return StaffPMApiFp(this.configuration).listStaffPMs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Staff PM id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resolveStaffPM(id: number, options?: RawAxiosRequestConfig) {
        return StaffPMApiFp(this.configuration).resolveStaffPM(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Staff PM id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public unresolveStaffPM(id: number, options?: RawAxiosRequestConfig) {
        return StaffPMApiFp(this.configuration).unresolveStaffPM(id, options).then((request) => request(this.axios, this.basePath));
    }
}


export const staffPMApi = new StaffPMApi(undefined, undefined, globalAxios);



export const createStaffPM = async (userCreatedStaffPm: UserCreatedStaffPm, options?: RawAxiosRequestConfig): Promise<StaffPm> => {
    const response = await staffPMApi.createStaffPM(userCreatedStaffPm, options);
    return response.data;
};


export const createStaffPMMessage = async (userCreatedStaffPmMessage: UserCreatedStaffPmMessage, options?: RawAxiosRequestConfig): Promise<StaffPmMessage> => {
    const response = await staffPMApi.createStaffPMMessage(userCreatedStaffPmMessage, options);
    return response.data;
};


export const getStaffPM = async (id: number, options?: RawAxiosRequestConfig): Promise<StaffPmHierarchy> => {
    const response = await staffPMApi.getStaffPM(id, options);
    return response.data;
};


export const listStaffPMs = async (options?: RawAxiosRequestConfig): Promise<Array<StaffPmOverview>> => {
    const response = await staffPMApi.listStaffPMs(options);
    return response.data;
};


export const resolveStaffPM = async (id: number, options?: RawAxiosRequestConfig): Promise<StaffPm> => {
    const response = await staffPMApi.resolveStaffPM(id, options);
    return response.data;
};


export const unresolveStaffPM = async (id: number, options?: RawAxiosRequestConfig): Promise<StaffPm> => {
    const response = await staffPMApi.unresolveStaffPM(id, options);
    return response.data;
};


/**
 * SubscriptionApi - axios parameter creator
 */
export const SubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForumThreadPostsSubscription: async (threadId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('createForumThreadPostsSubscription', 'threadId', threadId)
            const localVarPath = `/api/subscriptions/forum-thread-posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (threadId !== undefined) {
                localVarQueryParameter['thread_id'] = threadId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} titleGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTitleGroupTorrentsSubscription: async (titleGroupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'titleGroupId' is not null or undefined
            assertParamExists('createTitleGroupTorrentsSubscription', 'titleGroupId', titleGroupId)
            const localVarPath = `/api/subscriptions/title-group-torrents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (titleGroupId !== undefined) {
                localVarQueryParameter['title_group_id'] = titleGroupId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeForumThreadPostsSubscription: async (threadId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('removeForumThreadPostsSubscription', 'threadId', threadId)
            const localVarPath = `/api/subscriptions/forum-thread-posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (threadId !== undefined) {
                localVarQueryParameter['thread_id'] = threadId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} titleGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTitleGroupTorrentsSubscription: async (titleGroupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'titleGroupId' is not null or undefined
            assertParamExists('removeTitleGroupTorrentsSubscription', 'titleGroupId', titleGroupId)
            const localVarPath = `/api/subscriptions/title-group-torrents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (titleGroupId !== undefined) {
                localVarQueryParameter['title_group_id'] = titleGroupId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionApi - functional programming interface
 */
export const SubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createForumThreadPostsSubscription(threadId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createForumThreadPostsSubscription(threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.createForumThreadPostsSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} titleGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTitleGroupTorrentsSubscription(titleGroupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTitleGroupTorrentsSubscription(titleGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.createTitleGroupTorrentsSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeForumThreadPostsSubscription(threadId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeForumThreadPostsSubscription(threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.removeForumThreadPostsSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} titleGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTitleGroupTorrentsSubscription(titleGroupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTitleGroupTorrentsSubscription(titleGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.removeTitleGroupTorrentsSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionApi - factory interface
 */
export const SubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionApiFp(configuration)
    return {
        /**
         * 
         * @param {number} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForumThreadPostsSubscription(threadId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createForumThreadPostsSubscription(threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} titleGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTitleGroupTorrentsSubscription(titleGroupId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createTitleGroupTorrentsSubscription(titleGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeForumThreadPostsSubscription(threadId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeForumThreadPostsSubscription(threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} titleGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTitleGroupTorrentsSubscription(titleGroupId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeTitleGroupTorrentsSubscription(titleGroupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionApi - object-oriented interface
 */
export class SubscriptionApi extends BaseAPI {
    /**
     * 
     * @param {number} threadId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createForumThreadPostsSubscription(threadId: number, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).createForumThreadPostsSubscription(threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} titleGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTitleGroupTorrentsSubscription(titleGroupId: number, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).createTitleGroupTorrentsSubscription(titleGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} threadId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public removeForumThreadPostsSubscription(threadId: number, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).removeForumThreadPostsSubscription(threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} titleGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public removeTitleGroupTorrentsSubscription(titleGroupId: number, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).removeTitleGroupTorrentsSubscription(titleGroupId, options).then((request) => request(this.axios, this.basePath));
    }
}


export const subscriptionApi = new SubscriptionApi(undefined, undefined, globalAxios);



export const createForumThreadPostsSubscription = async (threadId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await subscriptionApi.createForumThreadPostsSubscription(threadId, options);
    return response.data;
};


export const createTitleGroupTorrentsSubscription = async (titleGroupId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await subscriptionApi.createTitleGroupTorrentsSubscription(titleGroupId, options);
    return response.data;
};


export const removeForumThreadPostsSubscription = async (threadId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await subscriptionApi.removeForumThreadPostsSubscription(threadId, options);
    return response.data;
};


export const removeTitleGroupTorrentsSubscription = async (titleGroupId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await subscriptionApi.removeTitleGroupTorrentsSubscription(titleGroupId, options);
    return response.data;
};


/**
 * TitleGroupApi - axios parameter creator
 */
export const TitleGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedTitleGroup} userCreatedTitleGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTitleGroup: async (userCreatedTitleGroup: UserCreatedTitleGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedTitleGroup' is not null or undefined
            assertParamExists('createTitleGroup', 'userCreatedTitleGroup', userCreatedTitleGroup)
            const localVarPath = `/api/title-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedTitleGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreatedTitleGroupComment} userCreatedTitleGroupComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTitleGroupComment: async (userCreatedTitleGroupComment: UserCreatedTitleGroupComment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedTitleGroupComment' is not null or undefined
            assertParamExists('createTitleGroupComment', 'userCreatedTitleGroupComment', userCreatedTitleGroupComment)
            const localVarPath = `/api/title-groups/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedTitleGroupComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditedTitleGroup} editedTitleGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTitleGroup: async (editedTitleGroup: EditedTitleGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editedTitleGroup' is not null or undefined
            assertParamExists('editTitleGroup', 'editedTitleGroup', editedTitleGroup)
            const localVarPath = `/api/title-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedTitleGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Comment id
         * @param {EditedTitleGroupComment} editedTitleGroupComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTitleGroupComment: async (id: number, editedTitleGroupComment: EditedTitleGroupComment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editTitleGroupComment', 'id', id)
            // verify required parameter 'editedTitleGroupComment' is not null or undefined
            assertParamExists('editTitleGroupComment', 'editedTitleGroupComment', editedTitleGroupComment)
            const localVarPath = `/api/title-groups/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedTitleGroupComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTitleGroup: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTitleGroup', 'id', id)
            const localVarPath = `/api/title-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTitleGroupInfoLite: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTitleGroupInfoLite', 'id', id)
            const localVarPath = `/api/title-groups/lite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TitleGroupApi - functional programming interface
 */
export const TitleGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TitleGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedTitleGroup} userCreatedTitleGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTitleGroup(userCreatedTitleGroup: UserCreatedTitleGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TitleGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTitleGroup(userCreatedTitleGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TitleGroupApi.createTitleGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreatedTitleGroupComment} userCreatedTitleGroupComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTitleGroupComment(userCreatedTitleGroupComment: UserCreatedTitleGroupComment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TitleGroupComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTitleGroupComment(userCreatedTitleGroupComment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TitleGroupApi.createTitleGroupComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditedTitleGroup} editedTitleGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editTitleGroup(editedTitleGroup: EditedTitleGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TitleGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editTitleGroup(editedTitleGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TitleGroupApi.editTitleGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id Comment id
         * @param {EditedTitleGroupComment} editedTitleGroupComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editTitleGroupComment(id: number, editedTitleGroupComment: EditedTitleGroupComment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TitleGroupComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editTitleGroupComment(id, editedTitleGroupComment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TitleGroupApi.editTitleGroupComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTitleGroup(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TitleGroupAndAssociatedData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTitleGroup(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TitleGroupApi.getTitleGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTitleGroupInfoLite(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TitleGroupLite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTitleGroupInfoLite(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TitleGroupApi.getTitleGroupInfoLite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TitleGroupApi - factory interface
 */
export const TitleGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TitleGroupApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedTitleGroup} userCreatedTitleGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTitleGroup(userCreatedTitleGroup: UserCreatedTitleGroup, options?: RawAxiosRequestConfig): AxiosPromise<TitleGroup> {
            return localVarFp.createTitleGroup(userCreatedTitleGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreatedTitleGroupComment} userCreatedTitleGroupComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTitleGroupComment(userCreatedTitleGroupComment: UserCreatedTitleGroupComment, options?: RawAxiosRequestConfig): AxiosPromise<TitleGroupComment> {
            return localVarFp.createTitleGroupComment(userCreatedTitleGroupComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditedTitleGroup} editedTitleGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTitleGroup(editedTitleGroup: EditedTitleGroup, options?: RawAxiosRequestConfig): AxiosPromise<TitleGroup> {
            return localVarFp.editTitleGroup(editedTitleGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Comment id
         * @param {EditedTitleGroupComment} editedTitleGroupComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTitleGroupComment(id: number, editedTitleGroupComment: EditedTitleGroupComment, options?: RawAxiosRequestConfig): AxiosPromise<TitleGroupComment> {
            return localVarFp.editTitleGroupComment(id, editedTitleGroupComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTitleGroup(id: number, options?: RawAxiosRequestConfig): AxiosPromise<TitleGroupAndAssociatedData> {
            return localVarFp.getTitleGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTitleGroupInfoLite(id: number, options?: RawAxiosRequestConfig): AxiosPromise<TitleGroupLite> {
            return localVarFp.getTitleGroupInfoLite(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TitleGroupApi - object-oriented interface
 */
export class TitleGroupApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedTitleGroup} userCreatedTitleGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTitleGroup(userCreatedTitleGroup: UserCreatedTitleGroup, options?: RawAxiosRequestConfig) {
        return TitleGroupApiFp(this.configuration).createTitleGroup(userCreatedTitleGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreatedTitleGroupComment} userCreatedTitleGroupComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTitleGroupComment(userCreatedTitleGroupComment: UserCreatedTitleGroupComment, options?: RawAxiosRequestConfig) {
        return TitleGroupApiFp(this.configuration).createTitleGroupComment(userCreatedTitleGroupComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditedTitleGroup} editedTitleGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editTitleGroup(editedTitleGroup: EditedTitleGroup, options?: RawAxiosRequestConfig) {
        return TitleGroupApiFp(this.configuration).editTitleGroup(editedTitleGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Comment id
     * @param {EditedTitleGroupComment} editedTitleGroupComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editTitleGroupComment(id: number, editedTitleGroupComment: EditedTitleGroupComment, options?: RawAxiosRequestConfig) {
        return TitleGroupApiFp(this.configuration).editTitleGroupComment(id, editedTitleGroupComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTitleGroup(id: number, options?: RawAxiosRequestConfig) {
        return TitleGroupApiFp(this.configuration).getTitleGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTitleGroupInfoLite(id: number, options?: RawAxiosRequestConfig) {
        return TitleGroupApiFp(this.configuration).getTitleGroupInfoLite(id, options).then((request) => request(this.axios, this.basePath));
    }
}


export const titleGroupApi = new TitleGroupApi(undefined, undefined, globalAxios);



export const createTitleGroup = async (userCreatedTitleGroup: UserCreatedTitleGroup, options?: RawAxiosRequestConfig): Promise<TitleGroup> => {
    const response = await titleGroupApi.createTitleGroup(userCreatedTitleGroup, options);
    return response.data;
};


export const createTitleGroupComment = async (userCreatedTitleGroupComment: UserCreatedTitleGroupComment, options?: RawAxiosRequestConfig): Promise<TitleGroupComment> => {
    const response = await titleGroupApi.createTitleGroupComment(userCreatedTitleGroupComment, options);
    return response.data;
};


export const editTitleGroup = async (editedTitleGroup: EditedTitleGroup, options?: RawAxiosRequestConfig): Promise<TitleGroup> => {
    const response = await titleGroupApi.editTitleGroup(editedTitleGroup, options);
    return response.data;
};

export interface EditTitleGroupCommentRequest {
    /** Comment id */
    'id': number;
    /**  */
    'EditedTitleGroupComment': EditedTitleGroupComment;
}


export const editTitleGroupComment = async (requestParameters: EditTitleGroupCommentRequest, options?: RawAxiosRequestConfig): Promise<TitleGroupComment> => {
    const response = await titleGroupApi.editTitleGroupComment(requestParameters['id']!, requestParameters['EditedTitleGroupComment']!, options);
    return response.data;
};


export const getTitleGroup = async (id: number, options?: RawAxiosRequestConfig): Promise<TitleGroupAndAssociatedData> => {
    const response = await titleGroupApi.getTitleGroup(id, options);
    return response.data;
};


export const getTitleGroupInfoLite = async (id: number, options?: RawAxiosRequestConfig): Promise<TitleGroupLite> => {
    const response = await titleGroupApi.getTitleGroupInfoLite(id, options);
    return response.data;
};


/**
 * TitleGroupTagApi - axios parameter creator
 */
export const TitleGroupTagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AppliedTitleGroupTag} appliedTitleGroupTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTagToTitleGroup: async (appliedTitleGroupTag: AppliedTitleGroupTag, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appliedTitleGroupTag' is not null or undefined
            assertParamExists('applyTagToTitleGroup', 'appliedTitleGroupTag', appliedTitleGroupTag)
            const localVarPath = `/api/title-group-tags/apply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appliedTitleGroupTag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreatedTitleGroupTag} userCreatedTitleGroupTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTitleGroupTag: async (userCreatedTitleGroupTag: UserCreatedTitleGroupTag, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedTitleGroupTag' is not null or undefined
            assertParamExists('createTitleGroupTag', 'userCreatedTitleGroupTag', userCreatedTitleGroupTag)
            const localVarPath = `/api/title-group-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedTitleGroupTag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteTagRequest} deleteTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTitleGroupTag: async (deleteTagRequest: DeleteTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteTagRequest' is not null or undefined
            assertParamExists('deleteTitleGroupTag', 'deleteTagRequest', deleteTagRequest)
            const localVarPath = `/api/title-group-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditedTitleGroupTag} editedTitleGroupTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTitleGroupTag: async (editedTitleGroupTag: EditedTitleGroupTag, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editedTitleGroupTag' is not null or undefined
            assertParamExists('editTitleGroupTag', 'editedTitleGroupTag', editedTitleGroupTag)
            const localVarPath = `/api/title-group-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedTitleGroupTag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RemovedTitleGroupTag} removedTitleGroupTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagFromTitleGroup: async (removedTitleGroupTag: RemovedTitleGroupTag, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'removedTitleGroupTag' is not null or undefined
            assertParamExists('removeTagFromTitleGroup', 'removedTitleGroupTag', removedTitleGroupTag)
            const localVarPath = `/api/title-group-tags/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removedTitleGroupTag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TitleGroupTagApi - functional programming interface
 */
export const TitleGroupTagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TitleGroupTagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AppliedTitleGroupTag} appliedTitleGroupTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyTagToTitleGroup(appliedTitleGroupTag: AppliedTitleGroupTag, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applyTagToTitleGroup(appliedTitleGroupTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TitleGroupTagApi.applyTagToTitleGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreatedTitleGroupTag} userCreatedTitleGroupTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTitleGroupTag(userCreatedTitleGroupTag: UserCreatedTitleGroupTag, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TitleGroupTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTitleGroupTag(userCreatedTitleGroupTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TitleGroupTagApi.createTitleGroupTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DeleteTagRequest} deleteTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTitleGroupTag(deleteTagRequest: DeleteTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTitleGroupTag(deleteTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TitleGroupTagApi.deleteTitleGroupTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditedTitleGroupTag} editedTitleGroupTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editTitleGroupTag(editedTitleGroupTag: EditedTitleGroupTag, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TitleGroupTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editTitleGroupTag(editedTitleGroupTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TitleGroupTagApi.editTitleGroupTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RemovedTitleGroupTag} removedTitleGroupTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTagFromTitleGroup(removedTitleGroupTag: RemovedTitleGroupTag, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTagFromTitleGroup(removedTitleGroupTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TitleGroupTagApi.removeTagFromTitleGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TitleGroupTagApi - factory interface
 */
export const TitleGroupTagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TitleGroupTagApiFp(configuration)
    return {
        /**
         * 
         * @param {AppliedTitleGroupTag} appliedTitleGroupTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTagToTitleGroup(appliedTitleGroupTag: AppliedTitleGroupTag, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.applyTagToTitleGroup(appliedTitleGroupTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreatedTitleGroupTag} userCreatedTitleGroupTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTitleGroupTag(userCreatedTitleGroupTag: UserCreatedTitleGroupTag, options?: RawAxiosRequestConfig): AxiosPromise<TitleGroupTag> {
            return localVarFp.createTitleGroupTag(userCreatedTitleGroupTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteTagRequest} deleteTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTitleGroupTag(deleteTagRequest: DeleteTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTitleGroupTag(deleteTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditedTitleGroupTag} editedTitleGroupTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTitleGroupTag(editedTitleGroupTag: EditedTitleGroupTag, options?: RawAxiosRequestConfig): AxiosPromise<TitleGroupTag> {
            return localVarFp.editTitleGroupTag(editedTitleGroupTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RemovedTitleGroupTag} removedTitleGroupTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagFromTitleGroup(removedTitleGroupTag: RemovedTitleGroupTag, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeTagFromTitleGroup(removedTitleGroupTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TitleGroupTagApi - object-oriented interface
 */
export class TitleGroupTagApi extends BaseAPI {
    /**
     * 
     * @param {AppliedTitleGroupTag} appliedTitleGroupTag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public applyTagToTitleGroup(appliedTitleGroupTag: AppliedTitleGroupTag, options?: RawAxiosRequestConfig) {
        return TitleGroupTagApiFp(this.configuration).applyTagToTitleGroup(appliedTitleGroupTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreatedTitleGroupTag} userCreatedTitleGroupTag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTitleGroupTag(userCreatedTitleGroupTag: UserCreatedTitleGroupTag, options?: RawAxiosRequestConfig) {
        return TitleGroupTagApiFp(this.configuration).createTitleGroupTag(userCreatedTitleGroupTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteTagRequest} deleteTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTitleGroupTag(deleteTagRequest: DeleteTagRequest, options?: RawAxiosRequestConfig) {
        return TitleGroupTagApiFp(this.configuration).deleteTitleGroupTag(deleteTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditedTitleGroupTag} editedTitleGroupTag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editTitleGroupTag(editedTitleGroupTag: EditedTitleGroupTag, options?: RawAxiosRequestConfig) {
        return TitleGroupTagApiFp(this.configuration).editTitleGroupTag(editedTitleGroupTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RemovedTitleGroupTag} removedTitleGroupTag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public removeTagFromTitleGroup(removedTitleGroupTag: RemovedTitleGroupTag, options?: RawAxiosRequestConfig) {
        return TitleGroupTagApiFp(this.configuration).removeTagFromTitleGroup(removedTitleGroupTag, options).then((request) => request(this.axios, this.basePath));
    }
}


export const titleGroupTagApi = new TitleGroupTagApi(undefined, undefined, globalAxios);



export const applyTagToTitleGroup = async (appliedTitleGroupTag: AppliedTitleGroupTag, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await titleGroupTagApi.applyTagToTitleGroup(appliedTitleGroupTag, options);
    return response.data;
};


export const createTitleGroupTag = async (userCreatedTitleGroupTag: UserCreatedTitleGroupTag, options?: RawAxiosRequestConfig): Promise<TitleGroupTag> => {
    const response = await titleGroupTagApi.createTitleGroupTag(userCreatedTitleGroupTag, options);
    return response.data;
};


export const deleteTitleGroupTag = async (deleteTagRequest: DeleteTagRequest, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await titleGroupTagApi.deleteTitleGroupTag(deleteTagRequest, options);
    return response.data;
};


export const editTitleGroupTag = async (editedTitleGroupTag: EditedTitleGroupTag, options?: RawAxiosRequestConfig): Promise<TitleGroupTag> => {
    const response = await titleGroupTagApi.editTitleGroupTag(editedTitleGroupTag, options);
    return response.data;
};


export const removeTagFromTitleGroup = async (removedTitleGroupTag: RemovedTitleGroupTag, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await titleGroupTagApi.removeTagFromTitleGroup(removedTitleGroupTag, options);
    return response.data;
};


/**
 * TorrentApi - axios parameter creator
 */
export const TorrentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} audioBitrate 
         * @param {AudioBitrateSampling} audioBitrateSampling 
         * @param {string} audioChannels 
         * @param {AudioCodec} audioCodec 
         * @param {string} container 
         * @param {string} description 
         * @param {number} duration 
         * @param {number} editionGroupId 
         * @param {string} extras 
         * @param {string} features 
         * @param {string} languages 
         * @param {string} mediainfo 
         * @param {string} releaseGroup 
         * @param {string} releaseName 
         * @param {string} subtitleLanguages 
         * @param {File} torrentFile 
         * @param {boolean} uploadedAsAnonymous 
         * @param {VideoCodec} videoCodec 
         * @param {VideoResolution} videoResolution 
         * @param {number} videoResolutionOtherX 
         * @param {number} videoResolutionOtherY 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTorrent: async (audioBitrate: number, audioBitrateSampling: AudioBitrateSampling, audioChannels: string, audioCodec: AudioCodec, container: string, description: string, duration: number, editionGroupId: number, extras: string, features: string, languages: string, mediainfo: string, releaseGroup: string, releaseName: string, subtitleLanguages: string, torrentFile: File, uploadedAsAnonymous: boolean, videoCodec: VideoCodec, videoResolution: VideoResolution, videoResolutionOtherX: number, videoResolutionOtherY: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audioBitrate' is not null or undefined
            assertParamExists('createTorrent', 'audioBitrate', audioBitrate)
            // verify required parameter 'audioBitrateSampling' is not null or undefined
            assertParamExists('createTorrent', 'audioBitrateSampling', audioBitrateSampling)
            // verify required parameter 'audioChannels' is not null or undefined
            assertParamExists('createTorrent', 'audioChannels', audioChannels)
            // verify required parameter 'audioCodec' is not null or undefined
            assertParamExists('createTorrent', 'audioCodec', audioCodec)
            // verify required parameter 'container' is not null or undefined
            assertParamExists('createTorrent', 'container', container)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('createTorrent', 'description', description)
            // verify required parameter 'duration' is not null or undefined
            assertParamExists('createTorrent', 'duration', duration)
            // verify required parameter 'editionGroupId' is not null or undefined
            assertParamExists('createTorrent', 'editionGroupId', editionGroupId)
            // verify required parameter 'extras' is not null or undefined
            assertParamExists('createTorrent', 'extras', extras)
            // verify required parameter 'features' is not null or undefined
            assertParamExists('createTorrent', 'features', features)
            // verify required parameter 'languages' is not null or undefined
            assertParamExists('createTorrent', 'languages', languages)
            // verify required parameter 'mediainfo' is not null or undefined
            assertParamExists('createTorrent', 'mediainfo', mediainfo)
            // verify required parameter 'releaseGroup' is not null or undefined
            assertParamExists('createTorrent', 'releaseGroup', releaseGroup)
            // verify required parameter 'releaseName' is not null or undefined
            assertParamExists('createTorrent', 'releaseName', releaseName)
            // verify required parameter 'subtitleLanguages' is not null or undefined
            assertParamExists('createTorrent', 'subtitleLanguages', subtitleLanguages)
            // verify required parameter 'torrentFile' is not null or undefined
            assertParamExists('createTorrent', 'torrentFile', torrentFile)
            // verify required parameter 'uploadedAsAnonymous' is not null or undefined
            assertParamExists('createTorrent', 'uploadedAsAnonymous', uploadedAsAnonymous)
            // verify required parameter 'videoCodec' is not null or undefined
            assertParamExists('createTorrent', 'videoCodec', videoCodec)
            // verify required parameter 'videoResolution' is not null or undefined
            assertParamExists('createTorrent', 'videoResolution', videoResolution)
            // verify required parameter 'videoResolutionOtherX' is not null or undefined
            assertParamExists('createTorrent', 'videoResolutionOtherX', videoResolutionOtherX)
            // verify required parameter 'videoResolutionOtherY' is not null or undefined
            assertParamExists('createTorrent', 'videoResolutionOtherY', videoResolutionOtherY)
            const localVarPath = `/api/torrents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (audioBitrate !== undefined) { 
                localVarFormParams.append('audio_bitrate', audioBitrate as any);
            }
    
            if (audioBitrateSampling !== undefined) { 
                localVarFormParams.append('audio_bitrate_sampling', audioBitrateSampling as any);
            }
    
            if (audioChannels !== undefined) { 
                localVarFormParams.append('audio_channels', audioChannels as any);
            }
    
            if (audioCodec !== undefined) { 
                localVarFormParams.append('audio_codec', audioCodec as any);
            }
    
            if (container !== undefined) { 
                localVarFormParams.append('container', container as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (duration !== undefined) { 
                localVarFormParams.append('duration', duration as any);
            }
    
            if (editionGroupId !== undefined) { 
                localVarFormParams.append('edition_group_id', editionGroupId as any);
            }
    
            if (extras !== undefined) { 
                localVarFormParams.append('extras', extras as any);
            }
    
            if (features !== undefined) { 
                localVarFormParams.append('features', features as any);
            }
    
            if (languages !== undefined) { 
                localVarFormParams.append('languages', languages as any);
            }
    
            if (mediainfo !== undefined) { 
                localVarFormParams.append('mediainfo', mediainfo as any);
            }
    
            if (releaseGroup !== undefined) { 
                localVarFormParams.append('release_group', releaseGroup as any);
            }
    
            if (releaseName !== undefined) { 
                localVarFormParams.append('release_name', releaseName as any);
            }
    
            if (subtitleLanguages !== undefined) { 
                localVarFormParams.append('subtitle_languages', subtitleLanguages as any);
            }
    
            if (torrentFile !== undefined) { 
                localVarFormParams.append('torrent_file', torrentFile as any);
            }
    
            if (uploadedAsAnonymous !== undefined) { 
                localVarFormParams.append('uploaded_as_anonymous', String(uploadedAsAnonymous) as any);
            }
    
            if (videoCodec !== undefined) { 
                localVarFormParams.append('video_codec', videoCodec as any);
            }
    
            if (videoResolution !== undefined) { 
                localVarFormParams.append('video_resolution', videoResolution as any);
            }
    
            if (videoResolutionOtherX !== undefined) { 
                localVarFormParams.append('video_resolution_other_x', videoResolutionOtherX as any);
            }
    
            if (videoResolutionOtherY !== undefined) { 
                localVarFormParams.append('video_resolution_other_y', videoResolutionOtherY as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreatedTorrentReport} userCreatedTorrentReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTorrentReport: async (userCreatedTorrentReport: UserCreatedTorrentReport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedTorrentReport' is not null or undefined
            assertParamExists('createTorrentReport', 'userCreatedTorrentReport', userCreatedTorrentReport)
            const localVarPath = `/api/torrents/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedTorrentReport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TorrentToDelete} torrentToDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTorrent: async (torrentToDelete: TorrentToDelete, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'torrentToDelete' is not null or undefined
            assertParamExists('deleteTorrent', 'torrentToDelete', torrentToDelete)
            const localVarPath = `/api/torrents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(torrentToDelete, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTorrentFile: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadTorrentFile', 'id', id)
            const localVarPath = `/api/torrents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditedTorrent} editedTorrent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTorrent: async (editedTorrent: EditedTorrent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editedTorrent' is not null or undefined
            assertParamExists('editTorrent', 'editedTorrent', editedTorrent)
            const localVarPath = `/api/torrents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedTorrent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} period 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopTorrent: async (period: string, amount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getTopTorrent', 'period', period)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('getTopTorrent', 'amount', amount)
            const localVarPath = `/api/torrents/top`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadInformation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/torrents/upload-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TorrentApi - functional programming interface
 */
export const TorrentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TorrentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} audioBitrate 
         * @param {AudioBitrateSampling} audioBitrateSampling 
         * @param {string} audioChannels 
         * @param {AudioCodec} audioCodec 
         * @param {string} container 
         * @param {string} description 
         * @param {number} duration 
         * @param {number} editionGroupId 
         * @param {string} extras 
         * @param {string} features 
         * @param {string} languages 
         * @param {string} mediainfo 
         * @param {string} releaseGroup 
         * @param {string} releaseName 
         * @param {string} subtitleLanguages 
         * @param {File} torrentFile 
         * @param {boolean} uploadedAsAnonymous 
         * @param {VideoCodec} videoCodec 
         * @param {VideoResolution} videoResolution 
         * @param {number} videoResolutionOtherX 
         * @param {number} videoResolutionOtherY 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTorrent(audioBitrate: number, audioBitrateSampling: AudioBitrateSampling, audioChannels: string, audioCodec: AudioCodec, container: string, description: string, duration: number, editionGroupId: number, extras: string, features: string, languages: string, mediainfo: string, releaseGroup: string, releaseName: string, subtitleLanguages: string, torrentFile: File, uploadedAsAnonymous: boolean, videoCodec: VideoCodec, videoResolution: VideoResolution, videoResolutionOtherX: number, videoResolutionOtherY: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Torrent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTorrent(audioBitrate, audioBitrateSampling, audioChannels, audioCodec, container, description, duration, editionGroupId, extras, features, languages, mediainfo, releaseGroup, releaseName, subtitleLanguages, torrentFile, uploadedAsAnonymous, videoCodec, videoResolution, videoResolutionOtherX, videoResolutionOtherY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TorrentApi.createTorrent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreatedTorrentReport} userCreatedTorrentReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTorrentReport(userCreatedTorrentReport: UserCreatedTorrentReport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TorrentReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTorrentReport(userCreatedTorrentReport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TorrentApi.createTorrentReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TorrentToDelete} torrentToDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTorrent(torrentToDelete: TorrentToDelete, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTorrent(torrentToDelete, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TorrentApi.deleteTorrent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTorrentFile(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTorrentFile(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TorrentApi.downloadTorrentFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditedTorrent} editedTorrent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editTorrent(editedTorrent: EditedTorrent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Torrent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editTorrent(editedTorrent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TorrentApi.editTorrent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} period 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopTorrent(period: string, amount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResultsTorrentHierarchyLite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopTorrent(period, amount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TorrentApi.getTopTorrent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUploadInformation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUploadInformation(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TorrentApi.getUploadInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TorrentApi - factory interface
 */
export const TorrentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TorrentApiFp(configuration)
    return {
        /**
         * 
         * @param {number} audioBitrate 
         * @param {AudioBitrateSampling} audioBitrateSampling 
         * @param {string} audioChannels 
         * @param {AudioCodec} audioCodec 
         * @param {string} container 
         * @param {string} description 
         * @param {number} duration 
         * @param {number} editionGroupId 
         * @param {string} extras 
         * @param {string} features 
         * @param {string} languages 
         * @param {string} mediainfo 
         * @param {string} releaseGroup 
         * @param {string} releaseName 
         * @param {string} subtitleLanguages 
         * @param {File} torrentFile 
         * @param {boolean} uploadedAsAnonymous 
         * @param {VideoCodec} videoCodec 
         * @param {VideoResolution} videoResolution 
         * @param {number} videoResolutionOtherX 
         * @param {number} videoResolutionOtherY 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTorrent(audioBitrate: number, audioBitrateSampling: AudioBitrateSampling, audioChannels: string, audioCodec: AudioCodec, container: string, description: string, duration: number, editionGroupId: number, extras: string, features: string, languages: string, mediainfo: string, releaseGroup: string, releaseName: string, subtitleLanguages: string, torrentFile: File, uploadedAsAnonymous: boolean, videoCodec: VideoCodec, videoResolution: VideoResolution, videoResolutionOtherX: number, videoResolutionOtherY: number, options?: RawAxiosRequestConfig): AxiosPromise<Torrent> {
            return localVarFp.createTorrent(audioBitrate, audioBitrateSampling, audioChannels, audioCodec, container, description, duration, editionGroupId, extras, features, languages, mediainfo, releaseGroup, releaseName, subtitleLanguages, torrentFile, uploadedAsAnonymous, videoCodec, videoResolution, videoResolutionOtherX, videoResolutionOtherY, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreatedTorrentReport} userCreatedTorrentReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTorrentReport(userCreatedTorrentReport: UserCreatedTorrentReport, options?: RawAxiosRequestConfig): AxiosPromise<TorrentReport> {
            return localVarFp.createTorrentReport(userCreatedTorrentReport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TorrentToDelete} torrentToDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTorrent(torrentToDelete: TorrentToDelete, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTorrent(torrentToDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTorrentFile(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.downloadTorrentFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditedTorrent} editedTorrent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTorrent(editedTorrent: EditedTorrent, options?: RawAxiosRequestConfig): AxiosPromise<Torrent> {
            return localVarFp.editTorrent(editedTorrent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} period 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopTorrent(period: string, amount: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResultsTorrentHierarchyLite> {
            return localVarFp.getTopTorrent(period, amount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadInformation(options?: RawAxiosRequestConfig): AxiosPromise<UploadInformation> {
            return localVarFp.getUploadInformation(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TorrentApi - object-oriented interface
 */
export class TorrentApi extends BaseAPI {
    /**
     * 
     * @param {number} audioBitrate 
     * @param {AudioBitrateSampling} audioBitrateSampling 
     * @param {string} audioChannels 
     * @param {AudioCodec} audioCodec 
     * @param {string} container 
     * @param {string} description 
     * @param {number} duration 
     * @param {number} editionGroupId 
     * @param {string} extras 
     * @param {string} features 
     * @param {string} languages 
     * @param {string} mediainfo 
     * @param {string} releaseGroup 
     * @param {string} releaseName 
     * @param {string} subtitleLanguages 
     * @param {File} torrentFile 
     * @param {boolean} uploadedAsAnonymous 
     * @param {VideoCodec} videoCodec 
     * @param {VideoResolution} videoResolution 
     * @param {number} videoResolutionOtherX 
     * @param {number} videoResolutionOtherY 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTorrent(audioBitrate: number, audioBitrateSampling: AudioBitrateSampling, audioChannels: string, audioCodec: AudioCodec, container: string, description: string, duration: number, editionGroupId: number, extras: string, features: string, languages: string, mediainfo: string, releaseGroup: string, releaseName: string, subtitleLanguages: string, torrentFile: File, uploadedAsAnonymous: boolean, videoCodec: VideoCodec, videoResolution: VideoResolution, videoResolutionOtherX: number, videoResolutionOtherY: number, options?: RawAxiosRequestConfig) {
        return TorrentApiFp(this.configuration).createTorrent(audioBitrate, audioBitrateSampling, audioChannels, audioCodec, container, description, duration, editionGroupId, extras, features, languages, mediainfo, releaseGroup, releaseName, subtitleLanguages, torrentFile, uploadedAsAnonymous, videoCodec, videoResolution, videoResolutionOtherX, videoResolutionOtherY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreatedTorrentReport} userCreatedTorrentReport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTorrentReport(userCreatedTorrentReport: UserCreatedTorrentReport, options?: RawAxiosRequestConfig) {
        return TorrentApiFp(this.configuration).createTorrentReport(userCreatedTorrentReport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TorrentToDelete} torrentToDelete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTorrent(torrentToDelete: TorrentToDelete, options?: RawAxiosRequestConfig) {
        return TorrentApiFp(this.configuration).deleteTorrent(torrentToDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadTorrentFile(id: number, options?: RawAxiosRequestConfig) {
        return TorrentApiFp(this.configuration).downloadTorrentFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditedTorrent} editedTorrent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editTorrent(editedTorrent: EditedTorrent, options?: RawAxiosRequestConfig) {
        return TorrentApiFp(this.configuration).editTorrent(editedTorrent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} period 
     * @param {number} amount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTopTorrent(period: string, amount: number, options?: RawAxiosRequestConfig) {
        return TorrentApiFp(this.configuration).getTopTorrent(period, amount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUploadInformation(options?: RawAxiosRequestConfig) {
        return TorrentApiFp(this.configuration).getUploadInformation(options).then((request) => request(this.axios, this.basePath));
    }
}


export const torrentApi = new TorrentApi(undefined, undefined, globalAxios);


export interface CreateTorrentRequest {
    /**  */
    'audio_bitrate': number;
    /**  */
    'audio_bitrate_sampling': AudioBitrateSampling;
    /**  */
    'audio_channels': string;
    /**  */
    'audio_codec': AudioCodec;
    /**  */
    'container': string;
    /**  */
    'description': string;
    /**  */
    'duration': number;
    /**  */
    'edition_group_id': number;
    /**  */
    'extras': string;
    /**  */
    'features': string;
    /**  */
    'languages': string;
    /**  */
    'mediainfo': string;
    /**  */
    'release_group': string;
    /**  */
    'release_name': string;
    /**  */
    'subtitle_languages': string;
    /**  */
    'torrent_file': File;
    /**  */
    'uploaded_as_anonymous': boolean;
    /**  */
    'video_codec': VideoCodec;
    /**  */
    'video_resolution': VideoResolution;
    /**  */
    'video_resolution_other_x': number;
    /**  */
    'video_resolution_other_y': number;
}


export const createTorrent = async (requestParameters: CreateTorrentRequest, options?: RawAxiosRequestConfig): Promise<Torrent> => {
    const response = await torrentApi.createTorrent(requestParameters['audio_bitrate']!, requestParameters['audio_bitrate_sampling']!, requestParameters['audio_channels']!, requestParameters['audio_codec']!, requestParameters['container']!, requestParameters['description']!, requestParameters['duration']!, requestParameters['edition_group_id']!, requestParameters['extras']!, requestParameters['features']!, requestParameters['languages']!, requestParameters['mediainfo']!, requestParameters['release_group']!, requestParameters['release_name']!, requestParameters['subtitle_languages']!, requestParameters['torrent_file']!, requestParameters['uploaded_as_anonymous']!, requestParameters['video_codec']!, requestParameters['video_resolution']!, requestParameters['video_resolution_other_x']!, requestParameters['video_resolution_other_y']!, options);
    return response.data;
};


export const createTorrentReport = async (userCreatedTorrentReport: UserCreatedTorrentReport, options?: RawAxiosRequestConfig): Promise<TorrentReport> => {
    const response = await torrentApi.createTorrentReport(userCreatedTorrentReport, options);
    return response.data;
};


export const deleteTorrent = async (torrentToDelete: TorrentToDelete, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await torrentApi.deleteTorrent(torrentToDelete, options);
    return response.data;
};


export const downloadTorrentFile = async (id: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await torrentApi.downloadTorrentFile(id, options);
    return response.data;
};


export const editTorrent = async (editedTorrent: EditedTorrent, options?: RawAxiosRequestConfig): Promise<Torrent> => {
    const response = await torrentApi.editTorrent(editedTorrent, options);
    return response.data;
};

export interface GetTopTorrentRequest {
    /**  */
    'period': string;
    /**  */
    'amount': number;
}


export const getTopTorrent = async (requestParameters: GetTopTorrentRequest, options?: RawAxiosRequestConfig): Promise<PaginatedResultsTorrentHierarchyLite> => {
    const response = await torrentApi.getTopTorrent(requestParameters['period']!, requestParameters['amount']!, options);
    return response.data;
};


export const getUploadInformation = async (options?: RawAxiosRequestConfig): Promise<UploadInformation> => {
    const response = await torrentApi.getUploadInformation(options);
    return response.data;
};


/**
 * TorrentRequestApi - axios parameter creator
 */
export const TorrentRequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedTorrentRequest} userCreatedTorrentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTorrentRequest: async (userCreatedTorrentRequest: UserCreatedTorrentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedTorrentRequest' is not null or undefined
            assertParamExists('createTorrentRequest', 'userCreatedTorrentRequest', userCreatedTorrentRequest)
            const localVarPath = `/api/torrent-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedTorrentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreatedTorrentRequestComment} userCreatedTorrentRequestComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTorrentRequestComment: async (userCreatedTorrentRequestComment: UserCreatedTorrentRequestComment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedTorrentRequestComment' is not null or undefined
            assertParamExists('createTorrentRequestComment', 'userCreatedTorrentRequestComment', userCreatedTorrentRequestComment)
            const localVarPath = `/api/torrent-requests/comment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedTorrentRequestComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreatedTorrentRequestVote} userCreatedTorrentRequestVote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTorrentRequestVote: async (userCreatedTorrentRequestVote: UserCreatedTorrentRequestVote, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedTorrentRequestVote' is not null or undefined
            assertParamExists('createTorrentRequestVote', 'userCreatedTorrentRequestVote', userCreatedTorrentRequestVote)
            const localVarPath = `/api/torrent-requests/vote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedTorrentRequestVote, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TorrentRequestFill} torrentRequestFill 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fillTorrentRequest: async (torrentRequestFill: TorrentRequestFill, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'torrentRequestFill' is not null or undefined
            assertParamExists('fillTorrentRequest', 'torrentRequestFill', torrentRequestFill)
            const localVarPath = `/api/torrent-requests/fill`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(torrentRequestFill, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTorrentRequest: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTorrentRequest', 'id', id)
            const localVarPath = `/api/torrent-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TorrentRequestApi - functional programming interface
 */
export const TorrentRequestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TorrentRequestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedTorrentRequest} userCreatedTorrentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTorrentRequest(userCreatedTorrentRequest: UserCreatedTorrentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TorrentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTorrentRequest(userCreatedTorrentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TorrentRequestApi.createTorrentRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreatedTorrentRequestComment} userCreatedTorrentRequestComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTorrentRequestComment(userCreatedTorrentRequestComment: UserCreatedTorrentRequestComment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TorrentRequestComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTorrentRequestComment(userCreatedTorrentRequestComment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TorrentRequestApi.createTorrentRequestComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreatedTorrentRequestVote} userCreatedTorrentRequestVote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTorrentRequestVote(userCreatedTorrentRequestVote: UserCreatedTorrentRequestVote, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TorrentRequestVote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTorrentRequestVote(userCreatedTorrentRequestVote, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TorrentRequestApi.createTorrentRequestVote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TorrentRequestFill} torrentRequestFill 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fillTorrentRequest(torrentRequestFill: TorrentRequestFill, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fillTorrentRequest(torrentRequestFill, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TorrentRequestApi.fillTorrentRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTorrentRequest(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TorrentRequestAndAssociatedData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTorrentRequest(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TorrentRequestApi.getTorrentRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TorrentRequestApi - factory interface
 */
export const TorrentRequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TorrentRequestApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedTorrentRequest} userCreatedTorrentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTorrentRequest(userCreatedTorrentRequest: UserCreatedTorrentRequest, options?: RawAxiosRequestConfig): AxiosPromise<TorrentRequest> {
            return localVarFp.createTorrentRequest(userCreatedTorrentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreatedTorrentRequestComment} userCreatedTorrentRequestComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTorrentRequestComment(userCreatedTorrentRequestComment: UserCreatedTorrentRequestComment, options?: RawAxiosRequestConfig): AxiosPromise<TorrentRequestComment> {
            return localVarFp.createTorrentRequestComment(userCreatedTorrentRequestComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreatedTorrentRequestVote} userCreatedTorrentRequestVote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTorrentRequestVote(userCreatedTorrentRequestVote: UserCreatedTorrentRequestVote, options?: RawAxiosRequestConfig): AxiosPromise<TorrentRequestVote> {
            return localVarFp.createTorrentRequestVote(userCreatedTorrentRequestVote, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TorrentRequestFill} torrentRequestFill 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fillTorrentRequest(torrentRequestFill: TorrentRequestFill, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.fillTorrentRequest(torrentRequestFill, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTorrentRequest(id: number, options?: RawAxiosRequestConfig): AxiosPromise<TorrentRequestAndAssociatedData> {
            return localVarFp.getTorrentRequest(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TorrentRequestApi - object-oriented interface
 */
export class TorrentRequestApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedTorrentRequest} userCreatedTorrentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTorrentRequest(userCreatedTorrentRequest: UserCreatedTorrentRequest, options?: RawAxiosRequestConfig) {
        return TorrentRequestApiFp(this.configuration).createTorrentRequest(userCreatedTorrentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreatedTorrentRequestComment} userCreatedTorrentRequestComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTorrentRequestComment(userCreatedTorrentRequestComment: UserCreatedTorrentRequestComment, options?: RawAxiosRequestConfig) {
        return TorrentRequestApiFp(this.configuration).createTorrentRequestComment(userCreatedTorrentRequestComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreatedTorrentRequestVote} userCreatedTorrentRequestVote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTorrentRequestVote(userCreatedTorrentRequestVote: UserCreatedTorrentRequestVote, options?: RawAxiosRequestConfig) {
        return TorrentRequestApiFp(this.configuration).createTorrentRequestVote(userCreatedTorrentRequestVote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TorrentRequestFill} torrentRequestFill 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public fillTorrentRequest(torrentRequestFill: TorrentRequestFill, options?: RawAxiosRequestConfig) {
        return TorrentRequestApiFp(this.configuration).fillTorrentRequest(torrentRequestFill, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTorrentRequest(id: number, options?: RawAxiosRequestConfig) {
        return TorrentRequestApiFp(this.configuration).getTorrentRequest(id, options).then((request) => request(this.axios, this.basePath));
    }
}


export const torrentRequestApi = new TorrentRequestApi(undefined, undefined, globalAxios);



export const createTorrentRequest = async (userCreatedTorrentRequest: UserCreatedTorrentRequest, options?: RawAxiosRequestConfig): Promise<TorrentRequest> => {
    const response = await torrentRequestApi.createTorrentRequest(userCreatedTorrentRequest, options);
    return response.data;
};


export const createTorrentRequestComment = async (userCreatedTorrentRequestComment: UserCreatedTorrentRequestComment, options?: RawAxiosRequestConfig): Promise<TorrentRequestComment> => {
    const response = await torrentRequestApi.createTorrentRequestComment(userCreatedTorrentRequestComment, options);
    return response.data;
};


export const createTorrentRequestVote = async (userCreatedTorrentRequestVote: UserCreatedTorrentRequestVote, options?: RawAxiosRequestConfig): Promise<TorrentRequestVote> => {
    const response = await torrentRequestApi.createTorrentRequestVote(userCreatedTorrentRequestVote, options);
    return response.data;
};


export const fillTorrentRequest = async (torrentRequestFill: TorrentRequestFill, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await torrentRequestApi.fillTorrentRequest(torrentRequestFill, options);
    return response.data;
};


export const getTorrentRequest = async (id: number, options?: RawAxiosRequestConfig): Promise<TorrentRequestAndAssociatedData> => {
    const response = await torrentRequestApi.getTorrentRequest(id, options);
    return response.data;
};


/**
 * UnauthorizedAccessApi - axios parameter creator
 */
export const UnauthorizedAccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} fromDate 
         * @param {string} toDate 
         * @param {UnauthorizedAccessSortByColumn} sortByColumn 
         * @param {SortByDirection} sortByDirection 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {number} [userId] 
         * @param {UserPermission | null} [permission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUnauthorizedAccessLogs: async (fromDate: string, toDate: string, sortByColumn: UnauthorizedAccessSortByColumn, sortByDirection: SortByDirection, page: number, pageSize: number, userId?: number, permission?: UserPermission | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('searchUnauthorizedAccessLogs', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('searchUnauthorizedAccessLogs', 'toDate', toDate)
            // verify required parameter 'sortByColumn' is not null or undefined
            assertParamExists('searchUnauthorizedAccessLogs', 'sortByColumn', sortByColumn)
            // verify required parameter 'sortByDirection' is not null or undefined
            assertParamExists('searchUnauthorizedAccessLogs', 'sortByDirection', sortByDirection)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('searchUnauthorizedAccessLogs', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('searchUnauthorizedAccessLogs', 'pageSize', pageSize)
            const localVarPath = `/api/unauthorized-access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }

            if (permission !== undefined) {
                localVarQueryParameter['permission'] = permission;
            }

            if (sortByColumn !== undefined) {
                localVarQueryParameter['sort_by_column'] = sortByColumn;
            }

            if (sortByDirection !== undefined) {
                localVarQueryParameter['sort_by_direction'] = sortByDirection;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UnauthorizedAccessApi - functional programming interface
 */
export const UnauthorizedAccessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UnauthorizedAccessApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} fromDate 
         * @param {string} toDate 
         * @param {UnauthorizedAccessSortByColumn} sortByColumn 
         * @param {SortByDirection} sortByDirection 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {number} [userId] 
         * @param {UserPermission | null} [permission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUnauthorizedAccessLogs(fromDate: string, toDate: string, sortByColumn: UnauthorizedAccessSortByColumn, sortByDirection: SortByDirection, page: number, pageSize: number, userId?: number, permission?: UserPermission | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResultsUnauthorizedAccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUnauthorizedAccessLogs(fromDate, toDate, sortByColumn, sortByDirection, page, pageSize, userId, permission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnauthorizedAccessApi.searchUnauthorizedAccessLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UnauthorizedAccessApi - factory interface
 */
export const UnauthorizedAccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UnauthorizedAccessApiFp(configuration)
    return {
        /**
         * 
         * @param {string} fromDate 
         * @param {string} toDate 
         * @param {UnauthorizedAccessSortByColumn} sortByColumn 
         * @param {SortByDirection} sortByDirection 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {number} [userId] 
         * @param {UserPermission | null} [permission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUnauthorizedAccessLogs(fromDate: string, toDate: string, sortByColumn: UnauthorizedAccessSortByColumn, sortByDirection: SortByDirection, page: number, pageSize: number, userId?: number, permission?: UserPermission | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResultsUnauthorizedAccess> {
            return localVarFp.searchUnauthorizedAccessLogs(fromDate, toDate, sortByColumn, sortByDirection, page, pageSize, userId, permission, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UnauthorizedAccessApi - object-oriented interface
 */
export class UnauthorizedAccessApi extends BaseAPI {
    /**
     * 
     * @param {string} fromDate 
     * @param {string} toDate 
     * @param {UnauthorizedAccessSortByColumn} sortByColumn 
     * @param {SortByDirection} sortByDirection 
     * @param {number} page 
     * @param {number} pageSize 
     * @param {number} [userId] 
     * @param {UserPermission | null} [permission] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchUnauthorizedAccessLogs(fromDate: string, toDate: string, sortByColumn: UnauthorizedAccessSortByColumn, sortByDirection: SortByDirection, page: number, pageSize: number, userId?: number, permission?: UserPermission | null, options?: RawAxiosRequestConfig) {
        return UnauthorizedAccessApiFp(this.configuration).searchUnauthorizedAccessLogs(fromDate, toDate, sortByColumn, sortByDirection, page, pageSize, userId, permission, options).then((request) => request(this.axios, this.basePath));
    }
}


export const unauthorizedAccessApi = new UnauthorizedAccessApi(undefined, undefined, globalAxios);


export interface SearchUnauthorizedAccessLogsRequest {
    /**  */
    'from_date': string;
    /**  */
    'to_date': string;
    /**  */
    'sort_by_column': UnauthorizedAccessSortByColumn;
    /**  */
    'sort_by_direction': SortByDirection;
    /**  */
    'page': number;
    /**  */
    'page_size': number;
    /**  */
    'user_id'?: number | null;
    /**  */
    'permission'?: UserPermission | null;
}


export const searchUnauthorizedAccessLogs = async (requestParameters: SearchUnauthorizedAccessLogsRequest, options?: RawAxiosRequestConfig): Promise<PaginatedResultsUnauthorizedAccess> => {
    const response = await unauthorizedAccessApi.searchUnauthorizedAccessLogs(requestParameters['from_date']!, requestParameters['to_date']!, requestParameters['sort_by_column']!, requestParameters['sort_by_direction']!, requestParameters['page']!, requestParameters['page_size']!, requestParameters['user_id']!, requestParameters['permission']!, options);
    return response.data;
};


/**
 * UserApi - axios parameter creator
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id User ID
         * @param {UserClassChange} userClassChange 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserClass: async (id: number, userClassChange: UserClassChange, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('changeUserClass', 'id', id)
            // verify required parameter 'userClassChange' is not null or undefined
            assertParamExists('changeUserClass', 'userClassChange', userClassChange)
            const localVarPath = `/api/users/{id}/class`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userClassChange, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditedUser} editedUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser: async (editedUser: EditedUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editedUser' is not null or undefined
            assertParamExists('editUser', 'editedUser', editedUser)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id User ID
         * @param {UpdatedUserPermissions} updatedUserPermissions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserPermissions: async (id: number, updatedUserPermissions: UpdatedUserPermissions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editUserPermissions', 'id', id)
            // verify required parameter 'updatedUserPermissions' is not null or undefined
            assertParamExists('editUserPermissions', 'updatedUserPermissions', updatedUserPermissions)
            const localVarPath = `/api/users/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatedUserPermissions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserConversations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPermissions: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserPermissions', 'id', id)
            const localVarPath = `/api/users/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id User ID
         * @param {UserClassLockStatus} userClassLockStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockUnlockUserClass: async (id: number, userClassLockStatus: UserClassLockStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lockUnlockUserClass', 'id', id)
            // verify required parameter 'userClassLockStatus' is not null or undefined
            assertParamExists('lockUnlockUserClass', 'userClassLockStatus', userClassLockStatus)
            const localVarPath = `/api/users/{id}/lock-class`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userClassLockStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserSettings} userSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSettings: async (userSettings: UserSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userSettings' is not null or undefined
            assertParamExists('updateUserSettings', 'userSettings', userSettings)
            const localVarPath = `/api/users/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreatedUserWarning} userCreatedUserWarning 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        warnUser: async (userCreatedUserWarning: UserCreatedUserWarning, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedUserWarning' is not null or undefined
            assertParamExists('warnUser', 'userCreatedUserWarning', userCreatedUserWarning)
            const localVarPath = `/api/users/warn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedUserWarning, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id User ID
         * @param {UserClassChange} userClassChange 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeUserClass(id: number, userClassChange: UserClassChange, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeUserClass(id, userClassChange, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.changeUserClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditedUser} editedUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUser(editedUser: EditedUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editUser(editedUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.editUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id User ID
         * @param {UpdatedUserPermissions} updatedUserPermissions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUserPermissions(id: number, updatedUserPermissions: UpdatedUserPermissions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editUserPermissions(id, updatedUserPermissions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.editUserPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserConversations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserConversations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserConversations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPermissions(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserPermission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPermissions(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id User ID
         * @param {UserClassLockStatus} userClassLockStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockUnlockUserClass(id: number, userClassLockStatus: UserClassLockStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockUnlockUserClass(id, userClassLockStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.lockUnlockUserClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserSettings} userSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSettings(userSettings: UserSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSettings(userSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUserSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreatedUserWarning} userCreatedUserWarning 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async warnUser(userCreatedUserWarning: UserCreatedUserWarning, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWarning>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.warnUser(userCreatedUserWarning, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.warnUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id User ID
         * @param {UserClassChange} userClassChange 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserClass(id: number, userClassChange: UserClassChange, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.changeUserClass(id, userClassChange, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditedUser} editedUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(editedUser: EditedUser, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editUser(editedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id User ID
         * @param {UpdatedUserPermissions} updatedUserPermissions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserPermissions(id: number, updatedUserPermissions: UpdatedUserPermissions, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editUserPermissions(id, updatedUserPermissions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: RawAxiosRequestConfig): AxiosPromise<Profile> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: number, options?: RawAxiosRequestConfig): AxiosPromise<PublicProfile> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserConversations(options?: RawAxiosRequestConfig): AxiosPromise<ConversationsOverview> {
            return localVarFp.getUserConversations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPermissions(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserPermission>> {
            return localVarFp.getUserPermissions(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings(options?: RawAxiosRequestConfig): AxiosPromise<UserSettings> {
            return localVarFp.getUserSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id User ID
         * @param {UserClassLockStatus} userClassLockStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockUnlockUserClass(id: number, userClassLockStatus: UserClassLockStatus, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.lockUnlockUserClass(id, userClassLockStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserSettings} userSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSettings(userSettings: UserSettings, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUserSettings(userSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreatedUserWarning} userCreatedUserWarning 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        warnUser(userCreatedUserWarning: UserCreatedUserWarning, options?: RawAxiosRequestConfig): AxiosPromise<UserWarning> {
            return localVarFp.warnUser(userCreatedUserWarning, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {number} id User ID
     * @param {UserClassChange} userClassChange 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changeUserClass(id: number, userClassChange: UserClassChange, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).changeUserClass(id, userClassChange, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditedUser} editedUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editUser(editedUser: EditedUser, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).editUser(editedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id User ID
     * @param {UpdatedUserPermissions} updatedUserPermissions 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editUserPermissions(id: number, updatedUserPermissions: UpdatedUserPermissions, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).editUserPermissions(id, updatedUserPermissions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMe(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUser(id: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserConversations(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserConversations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserPermissions(id: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserPermissions(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserSettings(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id User ID
     * @param {UserClassLockStatus} userClassLockStatus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public lockUnlockUserClass(id: number, userClassLockStatus: UserClassLockStatus, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).lockUnlockUserClass(id, userClassLockStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserSettings} userSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUserSettings(userSettings: UserSettings, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUserSettings(userSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreatedUserWarning} userCreatedUserWarning 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public warnUser(userCreatedUserWarning: UserCreatedUserWarning, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).warnUser(userCreatedUserWarning, options).then((request) => request(this.axios, this.basePath));
    }
}


export const userApi = new UserApi(undefined, undefined, globalAxios);


export interface ChangeUserClassRequest {
    /** User ID */
    'id': number;
    /**  */
    'UserClassChange': UserClassChange;
}


export const changeUserClass = async (requestParameters: ChangeUserClassRequest, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await userApi.changeUserClass(requestParameters['id']!, requestParameters['UserClassChange']!, options);
    return response.data;
};


export const editUser = async (editedUser: EditedUser, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await userApi.editUser(editedUser, options);
    return response.data;
};

export interface EditUserPermissionsRequest {
    /** User ID */
    'id': number;
    /**  */
    'UpdatedUserPermissions': UpdatedUserPermissions;
}


export const editUserPermissions = async (requestParameters: EditUserPermissionsRequest, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await userApi.editUserPermissions(requestParameters['id']!, requestParameters['UpdatedUserPermissions']!, options);
    return response.data;
};


export const getMe = async (options?: RawAxiosRequestConfig): Promise<Profile> => {
    const response = await userApi.getMe(options);
    return response.data;
};


export const getUser = async (id: number, options?: RawAxiosRequestConfig): Promise<PublicProfile> => {
    const response = await userApi.getUser(id, options);
    return response.data;
};


export const getUserConversations = async (options?: RawAxiosRequestConfig): Promise<ConversationsOverview> => {
    const response = await userApi.getUserConversations(options);
    return response.data;
};


export const getUserPermissions = async (id: number, options?: RawAxiosRequestConfig): Promise<Array<UserPermission>> => {
    const response = await userApi.getUserPermissions(id, options);
    return response.data;
};


export const getUserSettings = async (options?: RawAxiosRequestConfig): Promise<UserSettings> => {
    const response = await userApi.getUserSettings(options);
    return response.data;
};

export interface LockUnlockUserClassRequest {
    /** User ID */
    'id': number;
    /**  */
    'UserClassLockStatus': UserClassLockStatus;
}


export const lockUnlockUserClass = async (requestParameters: LockUnlockUserClassRequest, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await userApi.lockUnlockUserClass(requestParameters['id']!, requestParameters['UserClassLockStatus']!, options);
    return response.data;
};


export const updateUserSettings = async (userSettings: UserSettings, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await userApi.updateUserSettings(userSettings, options);
    return response.data;
};


export const warnUser = async (userCreatedUserWarning: UserCreatedUserWarning, options?: RawAxiosRequestConfig): Promise<UserWarning> => {
    const response = await userApi.warnUser(userCreatedUserWarning, options);
    return response.data;
};


/**
 * UserApplicationApi - axios parameter creator
 */
export const UserApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedUserApplication} userCreatedUserApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserApplication: async (userCreatedUserApplication: UserCreatedUserApplication, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedUserApplication' is not null or undefined
            assertParamExists('createUserApplication', 'userCreatedUserApplication', userCreatedUserApplication)
            const localVarPath = `/api/auth/apply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedUserApplication, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] Maximum number of applications to return (default: 50)
         * @param {number} [page] Page (default: 1)
         * @param {string} [status] Filter by application status: \&#39;pending\&#39;, \&#39;accepted\&#39;, or \&#39;rejected\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserApplications: async (pageSize?: number, page?: number, status?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserApplication} updateUserApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserApplicationStatus: async (updateUserApplication: UpdateUserApplication, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserApplication' is not null or undefined
            assertParamExists('updateUserApplicationStatus', 'updateUserApplication', updateUserApplication)
            const localVarPath = `/api/user-applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserApplication, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApplicationApi - functional programming interface
 */
export const UserApplicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApplicationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedUserApplication} userCreatedUserApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserApplication(userCreatedUserApplication: UserCreatedUserApplication, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserApplication(userCreatedUserApplication, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApplicationApi.createUserApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [pageSize] Maximum number of applications to return (default: 50)
         * @param {number} [page] Page (default: 1)
         * @param {string} [status] Filter by application status: \&#39;pending\&#39;, \&#39;accepted\&#39;, or \&#39;rejected\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserApplications(pageSize?: number, page?: number, status?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResultsUserApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserApplications(pageSize, page, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApplicationApi.getUserApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateUserApplication} updateUserApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserApplicationStatus(updateUserApplication: UpdateUserApplication, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserApplicationStatus(updateUserApplication, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApplicationApi.updateUserApplicationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApplicationApi - factory interface
 */
export const UserApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApplicationApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedUserApplication} userCreatedUserApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserApplication(userCreatedUserApplication: UserCreatedUserApplication, options?: RawAxiosRequestConfig): AxiosPromise<UserApplication> {
            return localVarFp.createUserApplication(userCreatedUserApplication, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] Maximum number of applications to return (default: 50)
         * @param {number} [page] Page (default: 1)
         * @param {string} [status] Filter by application status: \&#39;pending\&#39;, \&#39;accepted\&#39;, or \&#39;rejected\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserApplications(pageSize?: number, page?: number, status?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResultsUserApplication> {
            return localVarFp.getUserApplications(pageSize, page, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserApplication} updateUserApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserApplicationStatus(updateUserApplication: UpdateUserApplication, options?: RawAxiosRequestConfig): AxiosPromise<UserApplication> {
            return localVarFp.updateUserApplicationStatus(updateUserApplication, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApplicationApi - object-oriented interface
 */
export class UserApplicationApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedUserApplication} userCreatedUserApplication 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUserApplication(userCreatedUserApplication: UserCreatedUserApplication, options?: RawAxiosRequestConfig) {
        return UserApplicationApiFp(this.configuration).createUserApplication(userCreatedUserApplication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] Maximum number of applications to return (default: 50)
     * @param {number} [page] Page (default: 1)
     * @param {string} [status] Filter by application status: \&#39;pending\&#39;, \&#39;accepted\&#39;, or \&#39;rejected\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserApplications(pageSize?: number, page?: number, status?: string, options?: RawAxiosRequestConfig) {
        return UserApplicationApiFp(this.configuration).getUserApplications(pageSize, page, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserApplication} updateUserApplication 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUserApplicationStatus(updateUserApplication: UpdateUserApplication, options?: RawAxiosRequestConfig) {
        return UserApplicationApiFp(this.configuration).updateUserApplicationStatus(updateUserApplication, options).then((request) => request(this.axios, this.basePath));
    }
}


export const userApplicationApi = new UserApplicationApi(undefined, undefined, globalAxios);



export const createUserApplication = async (userCreatedUserApplication: UserCreatedUserApplication, options?: RawAxiosRequestConfig): Promise<UserApplication> => {
    const response = await userApplicationApi.createUserApplication(userCreatedUserApplication, options);
    return response.data;
};

export interface GetUserApplicationsRequest {
    /** Maximum number of applications to return (default: 50) */
    'page_size'?: number | null;
    /** Page (default: 1) */
    'page'?: number | null;
    /** Filter by application status: \&#39;pending\&#39;, \&#39;accepted\&#39;, or \&#39;rejected\&#39; */
    'status'?: string | null;
}


export const getUserApplications = async (requestParameters: GetUserApplicationsRequest, options?: RawAxiosRequestConfig): Promise<PaginatedResultsUserApplication> => {
    const response = await userApplicationApi.getUserApplications(requestParameters['page_size']!, requestParameters['page']!, requestParameters['status']!, options);
    return response.data;
};


export const updateUserApplicationStatus = async (updateUserApplication: UpdateUserApplication, options?: RawAxiosRequestConfig): Promise<UserApplication> => {
    const response = await userApplicationApi.updateUserApplicationStatus(updateUserApplication, options);
    return response.data;
};


/**
 * UserClassApi - axios parameter creator
 */
export const UserClassApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedUserClass} userCreatedUserClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserClass: async (userCreatedUserClass: UserCreatedUserClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedUserClass' is not null or undefined
            assertParamExists('createUserClass', 'userCreatedUserClass', userCreatedUserClass)
            const localVarPath = `/api/user-classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedUserClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name User class name to delete
         * @param {DeleteUserClass} deleteUserClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserClass: async (name: string, deleteUserClass: DeleteUserClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteUserClass', 'name', name)
            // verify required parameter 'deleteUserClass' is not null or undefined
            assertParamExists('deleteUserClass', 'deleteUserClass', deleteUserClass)
            const localVarPath = `/api/user-classes/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteUserClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name User class name
         * @param {EditedUserClass} editedUserClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserClass: async (name: string, editedUserClass: EditedUserClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('editUserClass', 'name', name)
            // verify required parameter 'editedUserClass' is not null or undefined
            assertParamExists('editUserClass', 'editedUserClass', editedUserClass)
            const localVarPath = `/api/user-classes/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedUserClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUserClasses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserClassApi - functional programming interface
 */
export const UserClassApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserClassApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedUserClass} userCreatedUserClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserClass(userCreatedUserClass: UserCreatedUserClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserClass(userCreatedUserClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserClassApi.createUserClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name User class name to delete
         * @param {DeleteUserClass} deleteUserClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserClass(name: string, deleteUserClass: DeleteUserClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserClass(name, deleteUserClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserClassApi.deleteUserClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name User class name
         * @param {EditedUserClass} editedUserClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUserClass(name: string, editedUserClass: EditedUserClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editUserClass(name, editedUserClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserClassApi.editUserClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUserClasses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserClass>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUserClasses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserClassApi.getAllUserClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserClassApi - factory interface
 */
export const UserClassApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserClassApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedUserClass} userCreatedUserClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserClass(userCreatedUserClass: UserCreatedUserClass, options?: RawAxiosRequestConfig): AxiosPromise<UserClass> {
            return localVarFp.createUserClass(userCreatedUserClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name User class name to delete
         * @param {DeleteUserClass} deleteUserClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserClass(name: string, deleteUserClass: DeleteUserClass, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserClass(name, deleteUserClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name User class name
         * @param {EditedUserClass} editedUserClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserClass(name: string, editedUserClass: EditedUserClass, options?: RawAxiosRequestConfig): AxiosPromise<UserClass> {
            return localVarFp.editUserClass(name, editedUserClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUserClasses(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserClass>> {
            return localVarFp.getAllUserClasses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserClassApi - object-oriented interface
 */
export class UserClassApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedUserClass} userCreatedUserClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUserClass(userCreatedUserClass: UserCreatedUserClass, options?: RawAxiosRequestConfig) {
        return UserClassApiFp(this.configuration).createUserClass(userCreatedUserClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name User class name to delete
     * @param {DeleteUserClass} deleteUserClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUserClass(name: string, deleteUserClass: DeleteUserClass, options?: RawAxiosRequestConfig) {
        return UserClassApiFp(this.configuration).deleteUserClass(name, deleteUserClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name User class name
     * @param {EditedUserClass} editedUserClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editUserClass(name: string, editedUserClass: EditedUserClass, options?: RawAxiosRequestConfig) {
        return UserClassApiFp(this.configuration).editUserClass(name, editedUserClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllUserClasses(options?: RawAxiosRequestConfig) {
        return UserClassApiFp(this.configuration).getAllUserClasses(options).then((request) => request(this.axios, this.basePath));
    }
}


export const userClassApi = new UserClassApi(undefined, undefined, globalAxios);



export const createUserClass = async (userCreatedUserClass: UserCreatedUserClass, options?: RawAxiosRequestConfig): Promise<UserClass> => {
    const response = await userClassApi.createUserClass(userCreatedUserClass, options);
    return response.data;
};

export interface DeleteUserClassRequest {
    /** User class name to delete */
    'name': string;
    /**  */
    'DeleteUserClass': DeleteUserClass;
}


export const deleteUserClass = async (requestParameters: DeleteUserClassRequest, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await userClassApi.deleteUserClass(requestParameters['name']!, requestParameters['DeleteUserClass']!, options);
    return response.data;
};

export interface EditUserClassRequest {
    /** User class name */
    'name': string;
    /**  */
    'EditedUserClass': EditedUserClass;
}


export const editUserClass = async (requestParameters: EditUserClassRequest, options?: RawAxiosRequestConfig): Promise<UserClass> => {
    const response = await userClassApi.editUserClass(requestParameters['name']!, requestParameters['EditedUserClass']!, options);
    return response.data;
};


export const getAllUserClasses = async (options?: RawAxiosRequestConfig): Promise<Array<UserClass>> => {
    const response = await userClassApi.getAllUserClasses(options);
    return response.data;
};


/**
 * WikiApi - axios parameter creator
 */
export const WikiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreatedWikiArticle} userCreatedWikiArticle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWikiArticle: async (userCreatedWikiArticle: UserCreatedWikiArticle, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreatedWikiArticle' is not null or undefined
            assertParamExists('createWikiArticle', 'userCreatedWikiArticle', userCreatedWikiArticle)
            const localVarPath = `/api/wiki/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreatedWikiArticle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditedWikiArticle} editedWikiArticle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWikiArticle: async (editedWikiArticle: EditedWikiArticle, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editedWikiArticle' is not null or undefined
            assertParamExists('editWikiArticle', 'editedWikiArticle', editedWikiArticle)
            const localVarPath = `/api/wiki/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editedWikiArticle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWikiArticle: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWikiArticle', 'id', id)
            const localVarPath = `/api/wiki/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WikiApi - functional programming interface
 */
export const WikiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WikiApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreatedWikiArticle} userCreatedWikiArticle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWikiArticle(userCreatedWikiArticle: UserCreatedWikiArticle, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiArticle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWikiArticle(userCreatedWikiArticle, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WikiApi.createWikiArticle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditedWikiArticle} editedWikiArticle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editWikiArticle(editedWikiArticle: EditedWikiArticle, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiArticle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editWikiArticle(editedWikiArticle, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WikiApi.editWikiArticle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWikiArticle(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiArticle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWikiArticle(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WikiApi.getWikiArticle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WikiApi - factory interface
 */
export const WikiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WikiApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreatedWikiArticle} userCreatedWikiArticle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWikiArticle(userCreatedWikiArticle: UserCreatedWikiArticle, options?: RawAxiosRequestConfig): AxiosPromise<WikiArticle> {
            return localVarFp.createWikiArticle(userCreatedWikiArticle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditedWikiArticle} editedWikiArticle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWikiArticle(editedWikiArticle: EditedWikiArticle, options?: RawAxiosRequestConfig): AxiosPromise<WikiArticle> {
            return localVarFp.editWikiArticle(editedWikiArticle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWikiArticle(id: number, options?: RawAxiosRequestConfig): AxiosPromise<WikiArticle> {
            return localVarFp.getWikiArticle(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WikiApi - object-oriented interface
 */
export class WikiApi extends BaseAPI {
    /**
     * 
     * @param {UserCreatedWikiArticle} userCreatedWikiArticle 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWikiArticle(userCreatedWikiArticle: UserCreatedWikiArticle, options?: RawAxiosRequestConfig) {
        return WikiApiFp(this.configuration).createWikiArticle(userCreatedWikiArticle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditedWikiArticle} editedWikiArticle 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editWikiArticle(editedWikiArticle: EditedWikiArticle, options?: RawAxiosRequestConfig) {
        return WikiApiFp(this.configuration).editWikiArticle(editedWikiArticle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWikiArticle(id: number, options?: RawAxiosRequestConfig) {
        return WikiApiFp(this.configuration).getWikiArticle(id, options).then((request) => request(this.axios, this.basePath));
    }
}


export const wikiApi = new WikiApi(undefined, undefined, globalAxios);



export const createWikiArticle = async (userCreatedWikiArticle: UserCreatedWikiArticle, options?: RawAxiosRequestConfig): Promise<WikiArticle> => {
    const response = await wikiApi.createWikiArticle(userCreatedWikiArticle, options);
    return response.data;
};


export const editWikiArticle = async (editedWikiArticle: EditedWikiArticle, options?: RawAxiosRequestConfig): Promise<WikiArticle> => {
    const response = await wikiApi.editWikiArticle(editedWikiArticle, options);
    return response.data;
};


export const getWikiArticle = async (id: number, options?: RawAxiosRequestConfig): Promise<WikiArticle> => {
    const response = await wikiApi.getWikiArticle(id, options);
    return response.data;
};



